{
    "instance_id": "astropy__astropy-11693",
    "text": "You will be provided with a partial code base and an issue statement explaining a problem to resolve.\n<issue>\n'WCS.all_world2pix' failed to converge when plotting WCS with non linear distortions\n<!-- This comments are hidden when you submit the issue,\r\nso you do not need to remove them! -->\r\n\r\n<!-- Please be sure to check out our contributing guidelines,\r\nhttps://github.com/astropy/astropy/blob/master/CONTRIBUTING.md .\r\nPlease be sure to check out our code of conduct,\r\nhttps://github.com/astropy/astropy/blob/master/CODE_OF_CONDUCT.md . -->\r\n\r\n<!-- Please have a search on our GitHub repository to see if a similar\r\nissue has already been posted.\r\nIf a similar issue is closed, have a quick look to see if you are satisfied\r\nby the resolution.\r\nIf not please go ahead and open an issue! -->\r\n\r\n<!-- Please check that the development version still produces the same bug.\r\nYou can install development version with\r\npip install git+https://github.com/astropy/astropy\r\ncommand. -->\r\n\r\n### Description\r\nWhen trying to plot an image with a WCS as projection that contains non linear Distortions it fails with a `NoConvergence` error.\r\n\r\n### Expected behavior\r\nWhen I add `quiet=True` as parameter to the call \r\n```pixel = self.all_world2pix(*world_arrays, 0)``` \r\nat line 326 of `astropy/wcs/wcsapi/fitswcs.py` I get the good enough looking plot below:\r\n\r\n![bugreport](https://user-images.githubusercontent.com/64231/112940287-37c2c800-912d-11eb-8ce8-56fd284bb8e7.png)\r\n\r\nIt would be nice if there was a way of getting that plot without having to hack the library code like that.\r\n### Actual behavior\r\n<!-- What actually happened. -->\r\n<!-- Was the output confusing or poorly described? -->\r\nThe call to plotting the grid fails with the following error (last few lines, can provide more if necessary):\r\n\r\n```\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcsapi/fitswcs.py in world_to_pixel_values(self, *world_arrays)\r\n    324 \r\n    325     def world_to_pixel_values(self, *world_arrays):\r\n--> 326         pixel = self.all_world2pix(*world_arrays, 0)\r\n    327         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\r\n    328 \r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/utils/decorators.py in wrapper(*args, **kwargs)\r\n    534                     warnings.warn(message, warning_type, stacklevel=2)\r\n    535 \r\n--> 536             return function(*args, **kwargs)\r\n    537 \r\n    538         return wrapper\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in all_world2pix(self, tolerance, maxiter, adaptive, detect_divergence, quiet, *args, **kwargs)\r\n   1886             raise ValueError(\"No basic WCS settings were created.\")\r\n   1887 \r\n-> 1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n   1890             self._all_world2pix(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _array_converter(self, func, sky, ra_dec_order, *args)\r\n   1335                     \"a 1-D array for each axis, followed by an origin.\")\r\n   1336 \r\n-> 1337             return _return_list_of_arrays(axes, origin)\r\n   1338 \r\n   1339         raise TypeError(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _return_list_of_arrays(axes, origin)\r\n   1289             if ra_dec_order and sky == 'input':\r\n   1290                 xy = self._denormalize_sky(xy)\r\n-> 1291             output = func(xy, origin)\r\n   1292             if ra_dec_order and sky == 'output':\r\n   1293                 output = self._normalize_sky(output)\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in <lambda>(*args, **kwargs)\r\n   1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n-> 1890             self._all_world2pix(\r\n   1891                 *args, tolerance=tolerance, maxiter=maxiter,\r\n   1892                 adaptive=adaptive, detect_divergence=detect_divergence,\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _all_world2pix(self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet)\r\n   1869                     slow_conv=ind, divergent=None)\r\n   1870             else:\r\n-> 1871                 raise NoConvergence(\r\n   1872                     \"'WCS.all_world2pix' failed to \"\r\n   1873                     \"converge to the requested accuracy.\\n\"\r\n\r\nNoConvergence: 'WCS.all_world2pix' failed to converge to the requested accuracy.\r\nAfter 20 iterations, the solution is diverging at least for one input point.\r\n```\r\n\r\n### Steps to Reproduce\r\n<!-- Ideally a code example could be provided so we can run it ourselves. -->\r\n<!-- If you are pasting code, use triple backticks (```) around\r\nyour code snippet. -->\r\n<!-- If necessary, sanitize your screen output to be pasted so you do not\r\nreveal secrets like tokens and passwords. -->\r\n\r\nHere is the code to reproduce the problem:\r\n```\r\nfrom astropy.wcs import WCS, Sip\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nwcs = WCS(naxis=2)\r\na = [[ 0.00000000e+00,  0.00000000e+00,  6.77532513e-07,\r\n        -1.76632141e-10],\r\n       [ 0.00000000e+00,  9.49130161e-06, -1.50614321e-07,\r\n         0.00000000e+00],\r\n       [ 7.37260409e-06,  2.07020239e-09,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [-1.20116753e-07,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\nb = [[ 0.00000000e+00,  0.00000000e+00,  1.34606617e-05,\r\n        -1.41919055e-07],\r\n       [ 0.00000000e+00,  5.85158316e-06, -1.10382462e-09,\r\n         0.00000000e+00],\r\n       [ 1.06306407e-05, -1.36469008e-07,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [ 3.27391123e-09,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\ncrpix = [1221.87375165,  994.90917378]\r\nap = bp = np.zeros((4, 4))\r\n\r\nwcs.sip = Sip(a, b, ap, bp, crpix)\r\n\r\nplt.subplot(projection=wcs)\r\nplt.imshow(np.zeros((1944, 2592)))\r\nplt.grid(color='white', ls='solid')\r\n```\r\n\r\n### System Details\r\n<!-- Even if you do not think this is necessary, it is useful information for the maintainers.\r\nPlease run the following snippet and paste the output below:\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"Numpy\", numpy.__version__)\r\nimport astropy; print(\"astropy\", astropy.__version__)\r\nimport scipy; print(\"Scipy\", scipy.__version__)\r\nimport matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\n-->\r\n```\r\n>>> import platform; print(platform.platform())\r\nLinux-5.11.10-arch1-1-x86_64-with-glibc2.33\r\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.9.2 (default, Feb 20 2021, 18:40:11) \r\n[GCC 10.2.0]\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.20.2\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 4.3.dev690+g7811614f8\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.6.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.3.4\r\n```\n'WCS.all_world2pix' failed to converge when plotting WCS with non linear distortions\n<!-- This comments are hidden when you submit the issue,\r\nso you do not need to remove them! -->\r\n\r\n<!-- Please be sure to check out our contributing guidelines,\r\nhttps://github.com/astropy/astropy/blob/master/CONTRIBUTING.md .\r\nPlease be sure to check out our code of conduct,\r\nhttps://github.com/astropy/astropy/blob/master/CODE_OF_CONDUCT.md . -->\r\n\r\n<!-- Please have a search on our GitHub repository to see if a similar\r\nissue has already been posted.\r\nIf a similar issue is closed, have a quick look to see if you are satisfied\r\nby the resolution.\r\nIf not please go ahead and open an issue! -->\r\n\r\n<!-- Please check that the development version still produces the same bug.\r\nYou can install development version with\r\npip install git+https://github.com/astropy/astropy\r\ncommand. -->\r\n\r\n### Description\r\nWhen trying to plot an image with a WCS as projection that contains non linear Distortions it fails with a `NoConvergence` error.\r\n\r\n### Expected behavior\r\nWhen I add `quiet=True` as parameter to the call \r\n```pixel = self.all_world2pix(*world_arrays, 0)``` \r\nat line 326 of `astropy/wcs/wcsapi/fitswcs.py` I get the good enough looking plot below:\r\n\r\n![bugreport](https://user-images.githubusercontent.com/64231/112940287-37c2c800-912d-11eb-8ce8-56fd284bb8e7.png)\r\n\r\nIt would be nice if there was a way of getting that plot without having to hack the library code like that.\r\n### Actual behavior\r\n<!-- What actually happened. -->\r\n<!-- Was the output confusing or poorly described? -->\r\nThe call to plotting the grid fails with the following error (last few lines, can provide more if necessary):\r\n\r\n```\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcsapi/fitswcs.py in world_to_pixel_values(self, *world_arrays)\r\n    324 \r\n    325     def world_to_pixel_values(self, *world_arrays):\r\n--> 326         pixel = self.all_world2pix(*world_arrays, 0)\r\n    327         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\r\n    328 \r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/utils/decorators.py in wrapper(*args, **kwargs)\r\n    534                     warnings.warn(message, warning_type, stacklevel=2)\r\n    535 \r\n--> 536             return function(*args, **kwargs)\r\n    537 \r\n    538         return wrapper\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in all_world2pix(self, tolerance, maxiter, adaptive, detect_divergence, quiet, *args, **kwargs)\r\n   1886             raise ValueError(\"No basic WCS settings were created.\")\r\n   1887 \r\n-> 1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n   1890             self._all_world2pix(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _array_converter(self, func, sky, ra_dec_order, *args)\r\n   1335                     \"a 1-D array for each axis, followed by an origin.\")\r\n   1336 \r\n-> 1337             return _return_list_of_arrays(axes, origin)\r\n   1338 \r\n   1339         raise TypeError(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _return_list_of_arrays(axes, origin)\r\n   1289             if ra_dec_order and sky == 'input':\r\n   1290                 xy = self._denormalize_sky(xy)\r\n-> 1291             output = func(xy, origin)\r\n   1292             if ra_dec_order and sky == 'output':\r\n   1293                 output = self._normalize_sky(output)\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in <lambda>(*args, **kwargs)\r\n   1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n-> 1890             self._all_world2pix(\r\n   1891                 *args, tolerance=tolerance, maxiter=maxiter,\r\n   1892                 adaptive=adaptive, detect_divergence=detect_divergence,\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _all_world2pix(self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet)\r\n   1869                     slow_conv=ind, divergent=None)\r\n   1870             else:\r\n-> 1871                 raise NoConvergence(\r\n   1872                     \"'WCS.all_world2pix' failed to \"\r\n   1873                     \"converge to the requested accuracy.\\n\"\r\n\r\nNoConvergence: 'WCS.all_world2pix' failed to converge to the requested accuracy.\r\nAfter 20 iterations, the solution is diverging at least for one input point.\r\n```\r\n\r\n### Steps to Reproduce\r\n<!-- Ideally a code example could be provided so we can run it ourselves. -->\r\n<!-- If you are pasting code, use triple backticks (```) around\r\nyour code snippet. -->\r\n<!-- If necessary, sanitize your screen output to be pasted so you do not\r\nreveal secrets like tokens and passwords. -->\r\n\r\nHere is the code to reproduce the problem:\r\n```\r\nfrom astropy.wcs import WCS, Sip\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nwcs = WCS(naxis=2)\r\na = [[ 0.00000000e+00,  0.00000000e+00,  6.77532513e-07,\r\n        -1.76632141e-10],\r\n       [ 0.00000000e+00,  9.49130161e-06, -1.50614321e-07,\r\n         0.00000000e+00],\r\n       [ 7.37260409e-06,  2.07020239e-09,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [-1.20116753e-07,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\nb = [[ 0.00000000e+00,  0.00000000e+00,  1.34606617e-05,\r\n        -1.41919055e-07],\r\n       [ 0.00000000e+00,  5.85158316e-06, -1.10382462e-09,\r\n         0.00000000e+00],\r\n       [ 1.06306407e-05, -1.36469008e-07,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [ 3.27391123e-09,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\ncrpix = [1221.87375165,  994.90917378]\r\nap = bp = np.zeros((4, 4))\r\n\r\nwcs.sip = Sip(a, b, ap, bp, crpix)\r\n\r\nplt.subplot(projection=wcs)\r\nplt.imshow(np.zeros((1944, 2592)))\r\nplt.grid(color='white', ls='solid')\r\n```\r\n\r\n### System Details\r\n<!-- Even if you do not think this is necessary, it is useful information for the maintainers.\r\nPlease run the following snippet and paste the output below:\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"Numpy\", numpy.__version__)\r\nimport astropy; print(\"astropy\", astropy.__version__)\r\nimport scipy; print(\"Scipy\", scipy.__version__)\r\nimport matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\n-->\r\n```\r\n>>> import platform; print(platform.platform())\r\nLinux-5.11.10-arch1-1-x86_64-with-glibc2.33\r\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.9.2 (default, Feb 20 2021, 18:40:11) \r\n[GCC 10.2.0]\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.20.2\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 4.3.dev690+g7811614f8\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.6.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.3.4\r\n```\n\n</issue>\n<code>\n[start of README.rst]\n1 =======\n2 Astropy\n3 =======\n4 \n5 |Actions Status| |CircleCI Status| |Azure Status| |Coverage Status| |PyPI Status| |Documentation Status| |Zenodo|\n6 \n7 The Astropy Project (http://astropy.org/) is a community effort to develop a\n8 single core package for Astronomy in Python and foster interoperability between\n9 Python astronomy packages. This repository contains the core package which is\n10 intended to contain much of the core functionality and some common tools needed\n11 for performing astronomy and astrophysics with Python.\n12 \n13 Releases are `registered on PyPI <https://pypi.org/project/astropy>`_,\n14 and development is occurring at the\n15 `project's GitHub page <http://github.com/astropy/astropy>`_.\n16 \n17 For installation instructions, see the `online documentation <https://docs.astropy.org/>`_\n18 or  `docs/install.rst <docs/install.rst>`_ in this source distribution.\n19 \n20 Contributing Code, Documentation, or Feedback\n21 ---------------------------------------------\n22 \n23 The Astropy Project is made both by and for its users, so we welcome and\n24 encourage contributions of many kinds. Our goal is to keep this a positive,\n25 inclusive, successful, and growing community by abiding with the\n26 `Astropy Community Code of Conduct <http://www.astropy.org/about.html#codeofconduct>`_.\n27 \n28 More detailed information on contributing to the project or submitting feedback\n29 can be found on the `contributions <http://www.astropy.org/contribute.html>`_\n30 page. A `summary of contribution guidelines <CONTRIBUTING.md>`_ can also be\n31 used as a quick reference when you are ready to start writing or validating\n32 code for submission.\n33 \n34 Supporting the Project\n35 ----------------------\n36 \n37 |NumFOCUS| |Donate|\n38 \n39 The Astropy Project is sponsored by NumFOCUS, a 501(c)(3) nonprofit in the\n40 United States. You can donate to the project by using the link above, and this\n41 donation will support our mission to promote sustainable, high-level code base\n42 for the astronomy community, open code development, educational materials, and\n43 reproducible scientific research.\n44 \n45 License\n46 -------\n47 \n48 Astropy is licensed under a 3-clause BSD style license - see the\n49 `LICENSE.rst <LICENSE.rst>`_ file.\n50 \n51 .. |Actions Status| image:: https://github.com/astropy/astropy/workflows/CI/badge.svg\n52     :target: https://github.com/astropy/astropy/actions\n53     :alt: Astropy's GitHub Actions CI Status\n54 \n55 .. |CircleCI Status| image::  https://img.shields.io/circleci/build/github/astropy/astropy/main?logo=circleci&label=CircleCI\n56     :target: https://circleci.com/gh/astropy/astropy\n57     :alt: Astropy's CircleCI Status\n58 \n59 .. |Azure Status| image:: https://dev.azure.com/astropy-project/astropy/_apis/build/status/astropy.astropy?repoName=astropy%2Fastropy&branchName=main\n60     :target: https://dev.azure.com/astropy-project/astropy\n61     :alt: Astropy's Azure Pipelines Status\n62 \n63 .. |Coverage Status| image:: https://codecov.io/gh/astropy/astropy/branch/main/graph/badge.svg\n64     :target: https://codecov.io/gh/astropy/astropy\n65     :alt: Astropy's Coverage Status\n66 \n67 .. |PyPI Status| image:: https://img.shields.io/pypi/v/astropy.svg\n68     :target: https://pypi.org/project/astropy\n69     :alt: Astropy's PyPI Status\n70 \n71 .. |Zenodo| image:: https://zenodo.org/badge/DOI/10.5281/zenodo.4670728.svg\n72    :target: https://doi.org/10.5281/zenodo.4670728\n73    :alt: Zenodo DOI\n74 \n75 .. |Documentation Status| image:: https://img.shields.io/readthedocs/astropy/latest.svg?logo=read%20the%20docs&logoColor=white&label=Docs&version=stable\n76     :target: https://docs.astropy.org/en/stable/?badge=stable\n77     :alt: Documentation Status\n78 \n79 .. |NumFOCUS| image:: https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A\n80     :target: http://numfocus.org\n81     :alt: Powered by NumFOCUS\n82 \n83 .. |Donate| image:: https://img.shields.io/badge/Donate-to%20Astropy-brightgreen.svg\n84     :target: https://numfocus.salsalabs.org/donate-to-astropy/index.html\n85 \n86 \n87 If you locally cloned this repo before 7 Apr 2021\n88 -------------------------------------------------\n89 \n90 The primary branch for this repo has been transitioned from ``master`` to\n91 ``main``.  If you have a local clone of this repository and want to keep your\n92 local branch in sync with this repo, you'll need to do the following in your\n93 local clone from your terminal::\n94 \n95    git fetch --all --prune\n96    # you can stop here if you don't use your local \"master\"/\"main\" branch\n97    git branch -m master main\n98    git branch -u origin/main main\n99 \n100 If you are using a GUI to manage your repos you'll have to find the equivalent\n101 commands as it's different for different programs. Alternatively, you can just\n102 delete your local clone and re-clone!\n103 \n[end of README.rst]\n[start of astropy/wcs/wcsapi/fitswcs.py]\n1 # This file includes the definition of a mix-in class that provides the low-\n2 # and high-level WCS API to the astropy.wcs.WCS object. We keep this code\n3 # isolated in this mix-in class to avoid making the main wcs.py file too\n4 # long.\n5 \n6 import warnings\n7 \n8 import numpy as np\n9 \n10 from astropy import units as u\n11 from astropy.coordinates import SpectralCoord, Galactic, ICRS\n12 from astropy.coordinates.spectral_coordinate import update_differentials_to_match, attach_zero_velocities\n13 from astropy.utils.exceptions import AstropyUserWarning\n14 from astropy.constants import c\n15 \n16 from .low_level_api import BaseLowLevelWCS\n17 from .high_level_api import HighLevelWCSMixin\n18 from .wrappers import SlicedLowLevelWCS\n19 \n20 __all__ = ['custom_ctype_to_ucd_mapping', 'SlicedFITSWCS', 'FITSWCSAPIMixin']\n21 \n22 C_SI = c.si.value\n23 \n24 VELOCITY_FRAMES = {\n25     'GEOCENT': 'gcrs',\n26     'BARYCENT': 'icrs',\n27     'HELIOCENT': 'hcrs',\n28     'LSRK': 'lsrk',\n29     'LSRD': 'lsrd'\n30 }\n31 \n32 # The spectra velocity frames below are needed for FITS spectral WCS\n33 #  (see Greisen 06 table 12) but aren't yet defined as real\n34 # astropy.coordinates frames, so we instead define them here as instances\n35 # of existing coordinate frames with offset velocities. In future we should\n36 # make these real frames so that users can more easily recognize these\n37 # velocity frames when used in SpectralCoord.\n38 \n39 # This frame is defined as a velocity of 220 km/s in the\n40 # direction of l=90, b=0. The rotation velocity is defined\n41 # in:\n42 #\n43 #   Kerr and Lynden-Bell 1986, Review of galactic constants.\n44 #\n45 # NOTE: this may differ from the assumptions of galcen_v_sun\n46 # in the Galactocentric frame - the value used here is\n47 # the one adopted by the WCS standard for spectral\n48 # transformations.\n49 \n50 VELOCITY_FRAMES['GALACTOC'] = Galactic(u=0 * u.km, v=0 * u.km, w=0 * u.km,\n51                                        U=0 * u.km / u.s, V=-220 * u.km / u.s, W=0 * u.km / u.s,\n52                                        representation_type='cartesian',\n53                                        differential_type='cartesian')\n54 \n55 # This frame is defined as a velocity of 300 km/s in the\n56 # direction of l=90, b=0. This is defined in:\n57 #\n58 #   Transactions of the IAU Vol. XVI B Proceedings of the\n59 #   16th General Assembly, Reports of Meetings of Commissions:\n60 #   Comptes Rendus Des Séances Des Commissions, Commission 28,\n61 #   p201.\n62 #\n63 # Note that these values differ from those used by CASA\n64 # (308 km/s towards l=105, b=-7) but we use the above values\n65 # since these are the ones defined in Greisen et al (2006).\n66 \n67 VELOCITY_FRAMES['LOCALGRP'] = Galactic(u=0 * u.km, v=0 * u.km, w=0 * u.km,\n68                                        U=0 * u.km / u.s, V=-300 * u.km / u.s, W=0 * u.km / u.s,\n69                                        representation_type='cartesian',\n70                                        differential_type='cartesian')\n71 \n72 # This frame is defined as a velocity of 368 km/s in the\n73 # direction of l=263.85, b=48.25. This is defined in:\n74 #\n75 #   Bennett et al. (2003), First-Year Wilkinson Microwave\n76 #   Anisotropy Probe (WMAP) Observations: Preliminary Maps\n77 #   and Basic Results\n78 #\n79 # Note that in that paper, the dipole is expressed as a\n80 # temperature (T=3.346 +/- 0.017mK)\n81 \n82 VELOCITY_FRAMES['CMBDIPOL'] = Galactic(l=263.85 * u.deg, b=48.25 * u.deg, distance=0 * u.km,\n83                                        radial_velocity=-(3.346e-3 / 2.725 * c).to(u.km/u.s))\n84 \n85 \n86 # Mapping from CTYPE axis name to UCD1\n87 \n88 CTYPE_TO_UCD1 = {\n89 \n90     # Celestial coordinates\n91     'RA': 'pos.eq.ra',\n92     'DEC': 'pos.eq.dec',\n93     'GLON': 'pos.galactic.lon',\n94     'GLAT': 'pos.galactic.lat',\n95     'ELON': 'pos.ecliptic.lon',\n96     'ELAT': 'pos.ecliptic.lat',\n97     'TLON': 'pos.bodyrc.lon',\n98     'TLAT': 'pos.bodyrc.lat',\n99     'HPLT': 'custom:pos.helioprojective.lat',\n100     'HPLN': 'custom:pos.helioprojective.lon',\n101     'HPRZ': 'custom:pos.helioprojective.z',\n102     'HGLN': 'custom:pos.heliographic.stonyhurst.lon',\n103     'HGLT': 'custom:pos.heliographic.stonyhurst.lat',\n104     'CRLN': 'custom:pos.heliographic.carrington.lon',\n105     'CRLT': 'custom:pos.heliographic.carrington.lat',\n106     'SOLX': 'custom:pos.heliocentric.x',\n107     'SOLY': 'custom:pos.heliocentric.y',\n108     'SOLZ': 'custom:pos.heliocentric.z',\n109 \n110     # Spectral coordinates (WCS paper 3)\n111     'FREQ': 'em.freq',  # Frequency\n112     'ENER': 'em.energy',  # Energy\n113     'WAVN': 'em.wavenumber',  # Wavenumber\n114     'WAVE': 'em.wl',  # Vacuum wavelength\n115     'VRAD': 'spect.dopplerVeloc.radio',  # Radio velocity\n116     'VOPT': 'spect.dopplerVeloc.opt',  # Optical velocity\n117     'ZOPT': 'src.redshift',  # Redshift\n118     'AWAV': 'em.wl',  # Air wavelength\n119     'VELO': 'spect.dopplerVeloc',  # Apparent radial velocity\n120     'BETA': 'custom:spect.doplerVeloc.beta',  # Beta factor (v/c)\n121     'STOKES': 'phys.polarization.stokes',  # STOKES parameters\n122 \n123     # Time coordinates (https://www.aanda.org/articles/aa/pdf/2015/02/aa24653-14.pdf)\n124     'TIME': 'time',\n125     'TAI': 'time',\n126     'TT': 'time',\n127     'TDT': 'time',\n128     'ET': 'time',\n129     'IAT': 'time',\n130     'UT1': 'time',\n131     'UTC': 'time',\n132     'GMT': 'time',\n133     'GPS': 'time',\n134     'TCG': 'time',\n135     'TCB': 'time',\n136     'TDB': 'time',\n137     'LOCAL': 'time',\n138 \n139     # Distance coordinates\n140     'DIST': 'pos.distance',\n141     'DSUN': 'custom:pos.distance.sunToObserver'\n142 \n143     # UT() and TT() are handled separately in world_axis_physical_types\n144 \n145 }\n146 \n147 # Keep a list of additional custom mappings that have been registered. This\n148 # is kept as a list in case nested context managers are used\n149 CTYPE_TO_UCD1_CUSTOM = []\n150 \n151 \n152 class custom_ctype_to_ucd_mapping:\n153     \"\"\"\n154     A context manager that makes it possible to temporarily add new CTYPE to\n155     UCD1+ mapping used by :attr:`FITSWCSAPIMixin.world_axis_physical_types`.\n156 \n157     Parameters\n158     ----------\n159     mapping : dict\n160         A dictionary mapping a CTYPE value to a UCD1+ value\n161 \n162     Examples\n163     --------\n164 \n165     Consider a WCS with the following CTYPE::\n166 \n167         >>> from astropy.wcs import WCS\n168         >>> wcs = WCS(naxis=1)\n169         >>> wcs.wcs.ctype = ['SPAM']\n170 \n171     By default, :attr:`FITSWCSAPIMixin.world_axis_physical_types` returns `None`,\n172     but this can be overridden::\n173 \n174         >>> wcs.world_axis_physical_types\n175         [None]\n176         >>> with custom_ctype_to_ucd_mapping({'SPAM': 'food.spam'}):\n177         ...     wcs.world_axis_physical_types\n178         ['food.spam']\n179     \"\"\"\n180 \n181     def __init__(self, mapping):\n182         CTYPE_TO_UCD1_CUSTOM.insert(0, mapping)\n183         self.mapping = mapping\n184 \n185     def __enter__(self):\n186         pass\n187 \n188     def __exit__(self, type, value, tb):\n189         CTYPE_TO_UCD1_CUSTOM.remove(self.mapping)\n190 \n191 \n192 class SlicedFITSWCS(SlicedLowLevelWCS, HighLevelWCSMixin):\n193     pass\n194 \n195 \n196 class FITSWCSAPIMixin(BaseLowLevelWCS, HighLevelWCSMixin):\n197     \"\"\"\n198     A mix-in class that is intended to be inherited by the\n199     :class:`~astropy.wcs.WCS` class and provides the low- and high-level WCS API\n200     \"\"\"\n201 \n202     @property\n203     def pixel_n_dim(self):\n204         return self.naxis\n205 \n206     @property\n207     def world_n_dim(self):\n208         return len(self.wcs.ctype)\n209 \n210     @property\n211     def array_shape(self):\n212         if self.pixel_shape is None:\n213             return None\n214         else:\n215             return self.pixel_shape[::-1]\n216 \n217     @array_shape.setter\n218     def array_shape(self, value):\n219         if value is None:\n220             self.pixel_shape = None\n221         else:\n222             self.pixel_shape = value[::-1]\n223 \n224     @property\n225     def pixel_shape(self):\n226         if self._naxis == [0, 0]:\n227             return None\n228         else:\n229             return tuple(self._naxis)\n230 \n231     @pixel_shape.setter\n232     def pixel_shape(self, value):\n233         if value is None:\n234             self._naxis = [0, 0]\n235         else:\n236             if len(value) != self.naxis:\n237                 raise ValueError(\"The number of data axes, \"\n238                                  \"{}, does not equal the \"\n239                                  \"shape {}.\".format(self.naxis, len(value)))\n240             self._naxis = list(value)\n241 \n242     @property\n243     def pixel_bounds(self):\n244         return self._pixel_bounds\n245 \n246     @pixel_bounds.setter\n247     def pixel_bounds(self, value):\n248         if value is None:\n249             self._pixel_bounds = value\n250         else:\n251             if len(value) != self.naxis:\n252                 raise ValueError(\"The number of data axes, \"\n253                                  \"{}, does not equal the number of \"\n254                                  \"pixel bounds {}.\".format(self.naxis, len(value)))\n255             self._pixel_bounds = list(value)\n256 \n257     @property\n258     def world_axis_physical_types(self):\n259         types = []\n260         # TODO: need to support e.g. TT(TAI)\n261         for ctype in self.wcs.ctype:\n262             if ctype.upper().startswith(('UT(', 'TT(')):\n263                 types.append('time')\n264             else:\n265                 ctype_name = ctype.split('-')[0]\n266                 for custom_mapping in CTYPE_TO_UCD1_CUSTOM:\n267                     if ctype_name in custom_mapping:\n268                         types.append(custom_mapping[ctype_name])\n269                         break\n270                 else:\n271                     types.append(CTYPE_TO_UCD1.get(ctype_name.upper(), None))\n272         return types\n273 \n274     @property\n275     def world_axis_units(self):\n276         units = []\n277         for unit in self.wcs.cunit:\n278             if unit is None:\n279                 unit = ''\n280             elif isinstance(unit, u.Unit):\n281                 unit = unit.to_string(format='vounit')\n282             else:\n283                 try:\n284                     unit = u.Unit(unit).to_string(format='vounit')\n285                 except u.UnitsError:\n286                     unit = ''\n287             units.append(unit)\n288         return units\n289 \n290     @property\n291     def world_axis_names(self):\n292         return list(self.wcs.cname)\n293 \n294     @property\n295     def axis_correlation_matrix(self):\n296 \n297         # If there are any distortions present, we assume that there may be\n298         # correlations between all axes. Maybe if some distortions only apply\n299         # to the image plane we can improve this?\n300         if self.has_distortion:\n301             return np.ones((self.world_n_dim, self.pixel_n_dim), dtype=bool)\n302 \n303         # Assuming linear world coordinates along each axis, the correlation\n304         # matrix would be given by whether or not the PC matrix is zero\n305         matrix = self.wcs.get_pc() != 0\n306 \n307         # We now need to check specifically for celestial coordinates since\n308         # these can assume correlations because of spherical distortions. For\n309         # each celestial coordinate we copy over the pixel dependencies from\n310         # the other celestial coordinates.\n311         celestial = (self.wcs.axis_types // 1000) % 10 == 2\n312         celestial_indices = np.nonzero(celestial)[0]\n313         for world1 in celestial_indices:\n314             for world2 in celestial_indices:\n315                 if world1 != world2:\n316                     matrix[world1] |= matrix[world2]\n317                     matrix[world2] |= matrix[world1]\n318 \n319         return matrix\n320 \n321     def pixel_to_world_values(self, *pixel_arrays):\n322         world = self.all_pix2world(*pixel_arrays, 0)\n323         return world[0] if self.world_n_dim == 1 else tuple(world)\n324 \n325     def world_to_pixel_values(self, *world_arrays):\n326         pixel = self.all_world2pix(*world_arrays, 0)\n327         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n328 \n329     @property\n330     def world_axis_object_components(self):\n331         return self._get_components_and_classes()[0]\n332 \n333     @property\n334     def world_axis_object_classes(self):\n335         return self._get_components_and_classes()[1]\n336 \n337     @property\n338     def serialized_classes(self):\n339         return False\n340 \n341     def _get_components_and_classes(self):\n342 \n343         # The aim of this function is to return whatever is needed for\n344         # world_axis_object_components and world_axis_object_classes. It's easier\n345         # to figure it out in one go and then return the values and let the\n346         # properties return part of it.\n347 \n348         # Since this method might get called quite a few times, we need to cache\n349         # it. We start off by defining a hash based on the attributes of the\n350         # WCS that matter here (we can't just use the WCS object as a hash since\n351         # it is mutable)\n352         wcs_hash = (self.naxis,\n353                     list(self.wcs.ctype),\n354                     list(self.wcs.cunit),\n355                     self.wcs.radesys,\n356                     self.wcs.specsys,\n357                     self.wcs.equinox,\n358                     self.wcs.dateobs,\n359                     self.wcs.lng,\n360                     self.wcs.lat)\n361 \n362         # If the cache is present, we need to check that the 'hash' matches.\n363         if getattr(self, '_components_and_classes_cache', None) is not None:\n364             cache = self._components_and_classes_cache\n365             if cache[0] == wcs_hash:\n366                 return cache[1]\n367             else:\n368                 self._components_and_classes_cache = None\n369 \n370         # Avoid circular imports by importing here\n371         from astropy.wcs.utils import wcs_to_celestial_frame\n372         from astropy.coordinates import SkyCoord, EarthLocation\n373         from astropy.time.formats import FITS_DEPRECATED_SCALES\n374         from astropy.time import Time, TimeDelta\n375 \n376         components = [None] * self.naxis\n377         classes = {}\n378 \n379         # Let's start off by checking whether the WCS has a pair of celestial\n380         # components\n381 \n382         if self.has_celestial:\n383 \n384             try:\n385                 celestial_frame = wcs_to_celestial_frame(self)\n386             except ValueError:\n387                 # Some WCSes, e.g. solar, can be recognized by WCSLIB as being\n388                 # celestial but we don't necessarily have frames for them.\n389                 celestial_frame = None\n390             else:\n391 \n392                 kwargs = {}\n393                 kwargs['frame'] = celestial_frame\n394                 kwargs['unit'] = u.deg\n395 \n396                 classes['celestial'] = (SkyCoord, (), kwargs)\n397 \n398                 components[self.wcs.lng] = ('celestial', 0, 'spherical.lon.degree')\n399                 components[self.wcs.lat] = ('celestial', 1, 'spherical.lat.degree')\n400 \n401         # Next, we check for spectral components\n402 \n403         if self.has_spectral:\n404 \n405             # Find index of spectral coordinate\n406             ispec = self.wcs.spec\n407             ctype = self.wcs.ctype[ispec][:4]\n408             ctype = ctype.upper()\n409 \n410             kwargs = {}\n411 \n412             # Determine observer location and velocity\n413 \n414             # TODO: determine how WCS standard would deal with observer on a\n415             # spacecraft far from earth. For now assume the obsgeo parameters,\n416             # if present, give the geocentric observer location.\n417 \n418             if np.isnan(self.wcs.obsgeo[0]):\n419                 observer = None\n420             else:\n421 \n422                 earth_location = EarthLocation(*self.wcs.obsgeo[:3], unit=u.m)\n423                 obstime = Time(self.wcs.mjdobs, format='mjd', scale='utc',\n424                                location=earth_location)\n425                 observer_location = SkyCoord(earth_location.get_itrs(obstime=obstime))\n426 \n427                 if self.wcs.specsys in VELOCITY_FRAMES:\n428                     frame = VELOCITY_FRAMES[self.wcs.specsys]\n429                     observer = observer_location.transform_to(frame)\n430                     if isinstance(frame, str):\n431                         observer = attach_zero_velocities(observer)\n432                     else:\n433                         observer = update_differentials_to_match(observer_location,\n434                                                                  VELOCITY_FRAMES[self.wcs.specsys],\n435                                                                  preserve_observer_frame=True)\n436                 elif self.wcs.specsys == 'TOPOCENT':\n437                     observer = attach_zero_velocities(observer_location)\n438                 else:\n439                     raise NotImplementedError(f'SPECSYS={self.wcs.specsys} not yet supported')\n440 \n441             # Determine target\n442 \n443             # This is tricker. In principle the target for each pixel is the\n444             # celestial coordinates of the pixel, but we then need to be very\n445             # careful about SSYSOBS which is tricky. For now, we set the\n446             # target using the reference celestial coordinate in the WCS (if\n447             # any).\n448 \n449             if self.has_celestial and celestial_frame is not None:\n450 \n451                 # NOTE: celestial_frame was defined higher up\n452 \n453                 # NOTE: we set the distance explicitly to avoid warnings in SpectralCoord\n454 \n455                 target = SkyCoord(self.wcs.crval[self.wcs.lng] * self.wcs.cunit[self.wcs.lng],\n456                                   self.wcs.crval[self.wcs.lat] * self.wcs.cunit[self.wcs.lat],\n457                                   frame=celestial_frame,\n458                                   distance=1000 * u.kpc)\n459 \n460                 target = attach_zero_velocities(target)\n461 \n462             else:\n463 \n464                 target = None\n465 \n466             # SpectralCoord does not work properly if either observer or target\n467             # are not convertible to ICRS, so if this is the case, we (for now)\n468             # drop the observer and target from the SpectralCoord and warn the\n469             # user.\n470 \n471             if observer is not None:\n472                 try:\n473                     observer.transform_to(ICRS())\n474                 except Exception:\n475                     warnings.warn('observer cannot be converted to ICRS, so will '\n476                                   'not be set on SpectralCoord', AstropyUserWarning)\n477                     observer = None\n478 \n479             if target is not None:\n480                 try:\n481                     target.transform_to(ICRS())\n482                 except Exception:\n483                     warnings.warn('target cannot be converted to ICRS, so will '\n484                                   'not be set on SpectralCoord', AstropyUserWarning)\n485                     target = None\n486 \n487             # NOTE: below we include Quantity in classes['spectral'] instead\n488             # of SpectralCoord - this is because we want to also be able to\n489             # accept plain quantities.\n490 \n491             if ctype == 'ZOPT':\n492 \n493                 def spectralcoord_from_redshift(redshift):\n494                     if isinstance(redshift, SpectralCoord):\n495                         return redshift\n496                     return SpectralCoord((redshift + 1) * self.wcs.restwav,\n497                                          unit=u.m, observer=observer, target=target)\n498 \n499                 def redshift_from_spectralcoord(spectralcoord):\n500                     # TODO: check target is consistent\n501                     if observer is None:\n502                         warnings.warn('No observer defined on WCS, SpectralCoord '\n503                                       'will be converted without any velocity '\n504                                       'frame change', AstropyUserWarning)\n505                         return spectralcoord.to_value(u.m) / self.wcs.restwav - 1.\n506                     else:\n507                         return spectralcoord.with_observer_stationary_relative_to(observer).to_value(u.m) / self.wcs.restwav - 1.\n508 \n509                 classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_redshift)\n510                 components[self.wcs.spec] = ('spectral', 0, redshift_from_spectralcoord)\n511 \n512             elif ctype == 'BETA':\n513 \n514                 def spectralcoord_from_beta(beta):\n515                     if isinstance(beta, SpectralCoord):\n516                         return beta\n517                     return SpectralCoord(beta * C_SI,\n518                                          unit=u.m / u.s,\n519                                          doppler_convention='relativistic',\n520                                          doppler_rest=self.wcs.restwav * u.m,\n521                                          observer=observer, target=target)\n522 \n523                 def beta_from_spectralcoord(spectralcoord):\n524                     # TODO: check target is consistent\n525                     doppler_equiv = u.doppler_relativistic(self.wcs.restwav * u.m)\n526                     if observer is None:\n527                         warnings.warn('No observer defined on WCS, SpectralCoord '\n528                                       'will be converted without any velocity '\n529                                       'frame change', AstropyUserWarning)\n530                         return spectralcoord.to_value(u.m / u.s, doppler_equiv) / C_SI\n531                     else:\n532                         return spectralcoord.with_observer_stationary_relative_to(observer).to_value(u.m / u.s, doppler_equiv) / C_SI\n533 \n534                 classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_beta)\n535                 components[self.wcs.spec] = ('spectral', 0, beta_from_spectralcoord)\n536 \n537             else:\n538 \n539                 kwargs['unit'] = self.wcs.cunit[ispec]\n540 \n541                 if self.wcs.restfrq > 0:\n542                     if ctype == 'VELO':\n543                         kwargs['doppler_convention'] = 'relativistic'\n544                         kwargs['doppler_rest'] = self.wcs.restfrq * u.Hz\n545                     elif ctype == 'VRAD':\n546                         kwargs['doppler_convention'] = 'radio'\n547                         kwargs['doppler_rest'] = self.wcs.restfrq * u.Hz\n548                     elif ctype == 'VOPT':\n549                         kwargs['doppler_convention'] = 'optical'\n550                         kwargs['doppler_rest'] = self.wcs.restwav * u.m\n551 \n552                 def spectralcoord_from_value(value):\n553                     return SpectralCoord(value, observer=observer, target=target, **kwargs)\n554 \n555                 def value_from_spectralcoord(spectralcoord):\n556                     # TODO: check target is consistent\n557                     if observer is None:\n558                         warnings.warn('No observer defined on WCS, SpectralCoord '\n559                                       'will be converted without any velocity '\n560                                       'frame change', AstropyUserWarning)\n561                         return spectralcoord.to_value(**kwargs)\n562                     else:\n563                         return spectralcoord.with_observer_stationary_relative_to(observer).to_value(**kwargs)\n564 \n565                 classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_value)\n566                 components[self.wcs.spec] = ('spectral', 0, value_from_spectralcoord)\n567 \n568         # We can then make sure we correctly return Time objects where appropriate\n569         # (https://www.aanda.org/articles/aa/pdf/2015/02/aa24653-14.pdf)\n570 \n571         if 'time' in self.world_axis_physical_types:\n572 \n573             multiple_time = self.world_axis_physical_types.count('time') > 1\n574 \n575             for i in range(self.naxis):\n576 \n577                 if self.world_axis_physical_types[i] == 'time':\n578 \n579                     if multiple_time:\n580                         name = f'time.{i}'\n581                     else:\n582                         name = 'time'\n583 \n584                     # Initialize delta\n585                     reference_time_delta = None\n586 \n587                     # Extract time scale\n588                     scale = self.wcs.ctype[i].lower()\n589 \n590                     if scale == 'time':\n591                         if self.wcs.timesys:\n592                             scale = self.wcs.timesys.lower()\n593                         else:\n594                             scale = 'utc'\n595 \n596                     # Drop sub-scales\n597                     if '(' in scale:\n598                         pos = scale.index('(')\n599                         scale, subscale = scale[:pos], scale[pos+1:-1]\n600                         warnings.warn(f'Dropping unsupported sub-scale '\n601                                       f'{subscale.upper()} from scale {scale.upper()}',\n602                                       UserWarning)\n603 \n604                     # TODO: consider having GPS as a scale in Time\n605                     # For now GPS is not a scale, we approximate this by TAI - 19s\n606                     if scale == 'gps':\n607                         reference_time_delta = TimeDelta(19, format='sec')\n608                         scale = 'tai'\n609 \n610                     elif scale.upper() in FITS_DEPRECATED_SCALES:\n611                         scale = FITS_DEPRECATED_SCALES[scale.upper()]\n612 \n613                     elif scale not in Time.SCALES:\n614                         raise ValueError(f'Unrecognized time CTYPE={self.wcs.ctype[i]}')\n615 \n616                     # Determine location\n617                     trefpos = self.wcs.trefpos.lower()\n618 \n619                     if trefpos.startswith('topocent'):\n620                         # Note that some headers use TOPOCENT instead of TOPOCENTER\n621                         if np.any(np.isnan(self.wcs.obsgeo[:3])):\n622                             warnings.warn('Missing or incomplete observer location '\n623                                           'information, setting location in Time to None',\n624                                           UserWarning)\n625                             location = None\n626                         else:\n627                             location = EarthLocation(*self.wcs.obsgeo[:3], unit=u.m)\n628                     elif trefpos == 'geocenter':\n629                         location = EarthLocation(0, 0, 0, unit=u.m)\n630                     elif trefpos == '':\n631                         location = None\n632                     else:\n633                         # TODO: implement support for more locations when Time supports it\n634                         warnings.warn(f\"Observation location '{trefpos}' is not \"\n635                                        \"supported, setting location in Time to None\", UserWarning)\n636                         location = None\n637 \n638                     reference_time = Time(np.nan_to_num(self.wcs.mjdref[0]),\n639                                           np.nan_to_num(self.wcs.mjdref[1]),\n640                                           format='mjd', scale=scale,\n641                                           location=location)\n642 \n643                     if reference_time_delta is not None:\n644                         reference_time = reference_time + reference_time_delta\n645 \n646                     def time_from_reference_and_offset(offset):\n647                         if isinstance(offset, Time):\n648                             return offset\n649                         return reference_time + TimeDelta(offset, format='sec')\n650 \n651                     def offset_from_time_and_reference(time):\n652                         return (time - reference_time).sec\n653 \n654                     classes[name] = (Time, (), {}, time_from_reference_and_offset)\n655                     components[i] = (name, 0, offset_from_time_and_reference)\n656 \n657         # Fallback: for any remaining components that haven't been identified, just\n658         # return Quantity as the class to use\n659 \n660         for i in range(self.naxis):\n661             if components[i] is None:\n662                 name = self.wcs.ctype[i].split('-')[0].lower()\n663                 if name == '':\n664                     name = 'world'\n665                 while name in classes:\n666                     name += \"_\"\n667                 classes[name] = (u.Quantity, (), {'unit': self.wcs.cunit[i]})\n668                 components[i] = (name, 0, 'value')\n669 \n670         # Keep a cached version of result\n671         self._components_and_classes_cache = wcs_hash, (components, classes)\n672 \n673         return components, classes\n674 \n[end of astropy/wcs/wcsapi/fitswcs.py]\n</code>\nI need you to solve this issue by generating a single patch file that I can apply directly to this repository using git apply. Please respond with a single patch file in the following format.\n<patch>\n--- a/file.py\n+++ b/file.py\n@@ -1,27 +1,35 @@\n def euclidean(a, b):\n-    while b:\n-        a, b = b, a % b\n-    return a\n+    if b == 0:\n+        return a\n+    return euclidean(b, a % b)\n \n \n def bresenham(x0, y0, x1, y1):\n     points = []\n     dx = abs(x1 - x0)\n     dy = abs(y1 - y0)\n-    sx = 1 if x0 < x1 else -1\n-    sy = 1 if y0 < y1 else -1\n-    err = dx - dy\n+    x, y = x0, y0\n+    sx = -1 if x0 > x1 else 1\n+    sy = -1 if y0 > y1 else 1\n \n-    while True:\n-        points.append((x0, y0))\n-        if x0 == x1 and y0 == y1:\n-            break\n-        e2 = 2 * err\n-        if e2 > -dy:\n+    if dx > dy:\n+        err = dx / 2.0\n+        while x != x1:\n+            points.append((x, y))\n             err -= dy\n-            x0 += sx\n-        if e2 < dx:\n-            err += dx\n-            y0 += sy\n+            if err < 0:\n+                y += sy\n+                err += dx\n+            x += sx\n+    else:\n+        err = dy / 2.0\n+        while y != y1:\n+            points.append((x, y))\n+            err -= dx\n+            if err < 0:\n+                x += sx\n+                err += dy\n+            y += sy\n \n+    points.append((x, y))\n     return points\n</patch>\n\n",
    "repo": "astropy/astropy",
    "base_commit": "3832210580d516365ddae1a62071001faf94d416",
    "problem_statement": "'WCS.all_world2pix' failed to converge when plotting WCS with non linear distortions\n<!-- This comments are hidden when you submit the issue,\r\nso you do not need to remove them! -->\r\n\r\n<!-- Please be sure to check out our contributing guidelines,\r\nhttps://github.com/astropy/astropy/blob/master/CONTRIBUTING.md .\r\nPlease be sure to check out our code of conduct,\r\nhttps://github.com/astropy/astropy/blob/master/CODE_OF_CONDUCT.md . -->\r\n\r\n<!-- Please have a search on our GitHub repository to see if a similar\r\nissue has already been posted.\r\nIf a similar issue is closed, have a quick look to see if you are satisfied\r\nby the resolution.\r\nIf not please go ahead and open an issue! -->\r\n\r\n<!-- Please check that the development version still produces the same bug.\r\nYou can install development version with\r\npip install git+https://github.com/astropy/astropy\r\ncommand. -->\r\n\r\n### Description\r\nWhen trying to plot an image with a WCS as projection that contains non linear Distortions it fails with a `NoConvergence` error.\r\n\r\n### Expected behavior\r\nWhen I add `quiet=True` as parameter to the call \r\n```pixel = self.all_world2pix(*world_arrays, 0)``` \r\nat line 326 of `astropy/wcs/wcsapi/fitswcs.py` I get the good enough looking plot below:\r\n\r\n![bugreport](https://user-images.githubusercontent.com/64231/112940287-37c2c800-912d-11eb-8ce8-56fd284bb8e7.png)\r\n\r\nIt would be nice if there was a way of getting that plot without having to hack the library code like that.\r\n### Actual behavior\r\n<!-- What actually happened. -->\r\n<!-- Was the output confusing or poorly described? -->\r\nThe call to plotting the grid fails with the following error (last few lines, can provide more if necessary):\r\n\r\n```\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcsapi/fitswcs.py in world_to_pixel_values(self, *world_arrays)\r\n    324 \r\n    325     def world_to_pixel_values(self, *world_arrays):\r\n--> 326         pixel = self.all_world2pix(*world_arrays, 0)\r\n    327         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\r\n    328 \r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/utils/decorators.py in wrapper(*args, **kwargs)\r\n    534                     warnings.warn(message, warning_type, stacklevel=2)\r\n    535 \r\n--> 536             return function(*args, **kwargs)\r\n    537 \r\n    538         return wrapper\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in all_world2pix(self, tolerance, maxiter, adaptive, detect_divergence, quiet, *args, **kwargs)\r\n   1886             raise ValueError(\"No basic WCS settings were created.\")\r\n   1887 \r\n-> 1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n   1890             self._all_world2pix(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _array_converter(self, func, sky, ra_dec_order, *args)\r\n   1335                     \"a 1-D array for each axis, followed by an origin.\")\r\n   1336 \r\n-> 1337             return _return_list_of_arrays(axes, origin)\r\n   1338 \r\n   1339         raise TypeError(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _return_list_of_arrays(axes, origin)\r\n   1289             if ra_dec_order and sky == 'input':\r\n   1290                 xy = self._denormalize_sky(xy)\r\n-> 1291             output = func(xy, origin)\r\n   1292             if ra_dec_order and sky == 'output':\r\n   1293                 output = self._normalize_sky(output)\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in <lambda>(*args, **kwargs)\r\n   1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n-> 1890             self._all_world2pix(\r\n   1891                 *args, tolerance=tolerance, maxiter=maxiter,\r\n   1892                 adaptive=adaptive, detect_divergence=detect_divergence,\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _all_world2pix(self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet)\r\n   1869                     slow_conv=ind, divergent=None)\r\n   1870             else:\r\n-> 1871                 raise NoConvergence(\r\n   1872                     \"'WCS.all_world2pix' failed to \"\r\n   1873                     \"converge to the requested accuracy.\\n\"\r\n\r\nNoConvergence: 'WCS.all_world2pix' failed to converge to the requested accuracy.\r\nAfter 20 iterations, the solution is diverging at least for one input point.\r\n```\r\n\r\n### Steps to Reproduce\r\n<!-- Ideally a code example could be provided so we can run it ourselves. -->\r\n<!-- If you are pasting code, use triple backticks (```) around\r\nyour code snippet. -->\r\n<!-- If necessary, sanitize your screen output to be pasted so you do not\r\nreveal secrets like tokens and passwords. -->\r\n\r\nHere is the code to reproduce the problem:\r\n```\r\nfrom astropy.wcs import WCS, Sip\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nwcs = WCS(naxis=2)\r\na = [[ 0.00000000e+00,  0.00000000e+00,  6.77532513e-07,\r\n        -1.76632141e-10],\r\n       [ 0.00000000e+00,  9.49130161e-06, -1.50614321e-07,\r\n         0.00000000e+00],\r\n       [ 7.37260409e-06,  2.07020239e-09,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [-1.20116753e-07,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\nb = [[ 0.00000000e+00,  0.00000000e+00,  1.34606617e-05,\r\n        -1.41919055e-07],\r\n       [ 0.00000000e+00,  5.85158316e-06, -1.10382462e-09,\r\n         0.00000000e+00],\r\n       [ 1.06306407e-05, -1.36469008e-07,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [ 3.27391123e-09,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\ncrpix = [1221.87375165,  994.90917378]\r\nap = bp = np.zeros((4, 4))\r\n\r\nwcs.sip = Sip(a, b, ap, bp, crpix)\r\n\r\nplt.subplot(projection=wcs)\r\nplt.imshow(np.zeros((1944, 2592)))\r\nplt.grid(color='white', ls='solid')\r\n```\r\n\r\n### System Details\r\n<!-- Even if you do not think this is necessary, it is useful information for the maintainers.\r\nPlease run the following snippet and paste the output below:\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"Numpy\", numpy.__version__)\r\nimport astropy; print(\"astropy\", astropy.__version__)\r\nimport scipy; print(\"Scipy\", scipy.__version__)\r\nimport matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\n-->\r\n```\r\n>>> import platform; print(platform.platform())\r\nLinux-5.11.10-arch1-1-x86_64-with-glibc2.33\r\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.9.2 (default, Feb 20 2021, 18:40:11) \r\n[GCC 10.2.0]\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.20.2\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 4.3.dev690+g7811614f8\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.6.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.3.4\r\n```\n'WCS.all_world2pix' failed to converge when plotting WCS with non linear distortions\n<!-- This comments are hidden when you submit the issue,\r\nso you do not need to remove them! -->\r\n\r\n<!-- Please be sure to check out our contributing guidelines,\r\nhttps://github.com/astropy/astropy/blob/master/CONTRIBUTING.md .\r\nPlease be sure to check out our code of conduct,\r\nhttps://github.com/astropy/astropy/blob/master/CODE_OF_CONDUCT.md . -->\r\n\r\n<!-- Please have a search on our GitHub repository to see if a similar\r\nissue has already been posted.\r\nIf a similar issue is closed, have a quick look to see if you are satisfied\r\nby the resolution.\r\nIf not please go ahead and open an issue! -->\r\n\r\n<!-- Please check that the development version still produces the same bug.\r\nYou can install development version with\r\npip install git+https://github.com/astropy/astropy\r\ncommand. -->\r\n\r\n### Description\r\nWhen trying to plot an image with a WCS as projection that contains non linear Distortions it fails with a `NoConvergence` error.\r\n\r\n### Expected behavior\r\nWhen I add `quiet=True` as parameter to the call \r\n```pixel = self.all_world2pix(*world_arrays, 0)``` \r\nat line 326 of `astropy/wcs/wcsapi/fitswcs.py` I get the good enough looking plot below:\r\n\r\n![bugreport](https://user-images.githubusercontent.com/64231/112940287-37c2c800-912d-11eb-8ce8-56fd284bb8e7.png)\r\n\r\nIt would be nice if there was a way of getting that plot without having to hack the library code like that.\r\n### Actual behavior\r\n<!-- What actually happened. -->\r\n<!-- Was the output confusing or poorly described? -->\r\nThe call to plotting the grid fails with the following error (last few lines, can provide more if necessary):\r\n\r\n```\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcsapi/fitswcs.py in world_to_pixel_values(self, *world_arrays)\r\n    324 \r\n    325     def world_to_pixel_values(self, *world_arrays):\r\n--> 326         pixel = self.all_world2pix(*world_arrays, 0)\r\n    327         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\r\n    328 \r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/utils/decorators.py in wrapper(*args, **kwargs)\r\n    534                     warnings.warn(message, warning_type, stacklevel=2)\r\n    535 \r\n--> 536             return function(*args, **kwargs)\r\n    537 \r\n    538         return wrapper\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in all_world2pix(self, tolerance, maxiter, adaptive, detect_divergence, quiet, *args, **kwargs)\r\n   1886             raise ValueError(\"No basic WCS settings were created.\")\r\n   1887 \r\n-> 1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n   1890             self._all_world2pix(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _array_converter(self, func, sky, ra_dec_order, *args)\r\n   1335                     \"a 1-D array for each axis, followed by an origin.\")\r\n   1336 \r\n-> 1337             return _return_list_of_arrays(axes, origin)\r\n   1338 \r\n   1339         raise TypeError(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _return_list_of_arrays(axes, origin)\r\n   1289             if ra_dec_order and sky == 'input':\r\n   1290                 xy = self._denormalize_sky(xy)\r\n-> 1291             output = func(xy, origin)\r\n   1292             if ra_dec_order and sky == 'output':\r\n   1293                 output = self._normalize_sky(output)\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in <lambda>(*args, **kwargs)\r\n   1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n-> 1890             self._all_world2pix(\r\n   1891                 *args, tolerance=tolerance, maxiter=maxiter,\r\n   1892                 adaptive=adaptive, detect_divergence=detect_divergence,\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _all_world2pix(self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet)\r\n   1869                     slow_conv=ind, divergent=None)\r\n   1870             else:\r\n-> 1871                 raise NoConvergence(\r\n   1872                     \"'WCS.all_world2pix' failed to \"\r\n   1873                     \"converge to the requested accuracy.\\n\"\r\n\r\nNoConvergence: 'WCS.all_world2pix' failed to converge to the requested accuracy.\r\nAfter 20 iterations, the solution is diverging at least for one input point.\r\n```\r\n\r\n### Steps to Reproduce\r\n<!-- Ideally a code example could be provided so we can run it ourselves. -->\r\n<!-- If you are pasting code, use triple backticks (```) around\r\nyour code snippet. -->\r\n<!-- If necessary, sanitize your screen output to be pasted so you do not\r\nreveal secrets like tokens and passwords. -->\r\n\r\nHere is the code to reproduce the problem:\r\n```\r\nfrom astropy.wcs import WCS, Sip\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nwcs = WCS(naxis=2)\r\na = [[ 0.00000000e+00,  0.00000000e+00,  6.77532513e-07,\r\n        -1.76632141e-10],\r\n       [ 0.00000000e+00,  9.49130161e-06, -1.50614321e-07,\r\n         0.00000000e+00],\r\n       [ 7.37260409e-06,  2.07020239e-09,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [-1.20116753e-07,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\nb = [[ 0.00000000e+00,  0.00000000e+00,  1.34606617e-05,\r\n        -1.41919055e-07],\r\n       [ 0.00000000e+00,  5.85158316e-06, -1.10382462e-09,\r\n         0.00000000e+00],\r\n       [ 1.06306407e-05, -1.36469008e-07,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [ 3.27391123e-09,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\ncrpix = [1221.87375165,  994.90917378]\r\nap = bp = np.zeros((4, 4))\r\n\r\nwcs.sip = Sip(a, b, ap, bp, crpix)\r\n\r\nplt.subplot(projection=wcs)\r\nplt.imshow(np.zeros((1944, 2592)))\r\nplt.grid(color='white', ls='solid')\r\n```\r\n\r\n### System Details\r\n<!-- Even if you do not think this is necessary, it is useful information for the maintainers.\r\nPlease run the following snippet and paste the output below:\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"Numpy\", numpy.__version__)\r\nimport astropy; print(\"astropy\", astropy.__version__)\r\nimport scipy; print(\"Scipy\", scipy.__version__)\r\nimport matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\n-->\r\n```\r\n>>> import platform; print(platform.platform())\r\nLinux-5.11.10-arch1-1-x86_64-with-glibc2.33\r\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.9.2 (default, Feb 20 2021, 18:40:11) \r\n[GCC 10.2.0]\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.20.2\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 4.3.dev690+g7811614f8\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.6.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.3.4\r\n```\n",
    "hints_text": "Welcome to Astropy 👋 and thank you for your first issue!\n\nA project member will respond to you as soon as possible; in the meantime, please double-check the [guidelines for submitting issues](https://github.com/astropy/astropy/blob/master/CONTRIBUTING.md#reporting-issues) and make sure you've provided the requested details.\n\nIf you feel that this issue has not been responded to in a timely manner, please leave a comment mentioning our software support engineer @embray, or send a message directly to the [development mailing list](http://groups.google.com/group/astropy-dev).  If the issue is urgent or sensitive in nature (e.g., a security vulnerability) please send an e-mail directly to the private e-mail feedback@astropy.org.\nYou could also directly call\r\n\r\n```python\r\npixel = self.all_world2pix(*world_arrays, 0)\r\npixel = pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\r\n```\r\n\r\nwithout patching any code.  But I wonder if the WCSAPI methods shouldn't allow passing additional keyword args to the underlying WCS methods (like `all_world2pix` in this case).  @astrofrog is the one who first introduces this API I think.\nI think the cleanest fix here would be that really the FITS WCS APE14 wrapper should call all_* in a way that only emits a warning not raises an exception (since by design we can't pass kwargs through). It's then easy for users to ignore the warning if they really want.\n\n@Cadair any thoughts?\n\nIs this technically a bug?\n> the FITS WCS APE14 wrapper should call all_* in a way that only emits a warning\r\n\r\nThis is probably the best solution. I certainly can't think of a better one.\r\n\r\nOn keyword arguments to WCSAPI, if we did allow that we would have to mandate that all implementations allowed `**kwargs` to accept and ignore all unknown kwargs so that you didn't make it implementation specific when calling the method, which is a big ugly.\n> Is this technically a bug?\r\n\r\nI would say so yes.\n> > the FITS WCS APE14 wrapper should call all_* in a way that only emits a warning\r\n> \r\n> This is probably the best solution. I certainly can't think of a better one.\r\n> \r\n\r\nThat solution would be also fine for me.\r\n\r\n\n@karlwessel , are you interested in submitting a patch for this? 😸 \nIn principle yes, but at the moment I really can't say.\r\n\r\nWhich places would this affect? Only all calls to `all_*` in `wcsapi/fitswcs.py`?\nYes I think that's right\nFor what it is worth, my comment is about the issues with the example. I think so far the history of `all_pix2world` shows that it is a very stable algorithm that converges for all \"real\" astronomical images. So, I wanted to learn about this failure. [NOTE: This does not mean that you should not catch exceptions in `pixel_to_world()` if you wish so.]\r\n\r\nThere are several issues with the example:\r\n1. Because `CTYPE` is not set, essentially the projection algorithm is linear, that is, intermediate physical coordinates are the world coordinates.\r\n2. SIP standard assumes that polynomials share the same CRPIX with the WCS. Here, CRPIX of the `Wcsprm` is `[0, 0]` while the CRPIX of the SIP is set to `[1221.87375165,  994.90917378]`\r\n3. If you run `wcs.all_pix2world(1, 1, 1)` you will get `[421.5126801, 374.13077558]` for world coordinates (and at CRPIX you will get CRVAL which is 0). This is in degrees. You can see that from the center pixel (CRPIX) to the corner of the image you are circling the celestial sphere many times (well, at least once; I did not check the other corners).\r\n\r\nIn summary, yes `all_world2pix` can fail but it does not imply that there is a bug in it. This example simply contains large distortions (like mapping `(1, 1) -> [421, 374]`) that cannot be handled with the currently implemented algorithm but I am not sure there is another algorithm that could do better.\r\n\r\nWith regard to throwing or not an exception... that's tough. On one hand, for those who are interested in correctness of the values, it is better to know that the algorithm failed and one cannot trust returned values. For plotting, this may be an issue and one would prefer to just get, maybe, the linear approximation. My personal preference is for exceptions because they can be caught and dealt with by the caller.\nThe example is a minimal version of our real WCS whichs nonlinear distortion is taken from a checkerboard image and it fits it quit well:\r\n![fitteddistortion](https://user-images.githubusercontent.com/64231/116892995-be892a00-ac30-11eb-826f-99e3635af1fa.png)\r\n\r\nThe WCS was fitted with `fit_wcs_from_points` using an artificial very small 'RA/DEC-TAN' grid so that it is almost linear.\r\n\r\nI guess the Problem is that the camera really has a huge distortion which just isn't fitable with a polynomial. Nevertheless it still is a real camera distortion, but I agree in that it probably is not worth to be considered a bug in the `all_world2pix` method.\nWelcome to Astropy 👋 and thank you for your first issue!\n\nA project member will respond to you as soon as possible; in the meantime, please double-check the [guidelines for submitting issues](https://github.com/astropy/astropy/blob/master/CONTRIBUTING.md#reporting-issues) and make sure you've provided the requested details.\n\nIf you feel that this issue has not been responded to in a timely manner, please leave a comment mentioning our software support engineer @embray, or send a message directly to the [development mailing list](http://groups.google.com/group/astropy-dev).  If the issue is urgent or sensitive in nature (e.g., a security vulnerability) please send an e-mail directly to the private e-mail feedback@astropy.org.\nYou could also directly call\r\n\r\n```python\r\npixel = self.all_world2pix(*world_arrays, 0)\r\npixel = pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\r\n```\r\n\r\nwithout patching any code.  But I wonder if the WCSAPI methods shouldn't allow passing additional keyword args to the underlying WCS methods (like `all_world2pix` in this case).  @astrofrog is the one who first introduces this API I think.\nI think the cleanest fix here would be that really the FITS WCS APE14 wrapper should call all_* in a way that only emits a warning not raises an exception (since by design we can't pass kwargs through). It's then easy for users to ignore the warning if they really want.\n\n@Cadair any thoughts?\n\nIs this technically a bug?\n> the FITS WCS APE14 wrapper should call all_* in a way that only emits a warning\r\n\r\nThis is probably the best solution. I certainly can't think of a better one.\r\n\r\nOn keyword arguments to WCSAPI, if we did allow that we would have to mandate that all implementations allowed `**kwargs` to accept and ignore all unknown kwargs so that you didn't make it implementation specific when calling the method, which is a big ugly.\n> Is this technically a bug?\r\n\r\nI would say so yes.\n> > the FITS WCS APE14 wrapper should call all_* in a way that only emits a warning\r\n> \r\n> This is probably the best solution. I certainly can't think of a better one.\r\n> \r\n\r\nThat solution would be also fine for me.\r\n\r\n\n@karlwessel , are you interested in submitting a patch for this? 😸 \nIn principle yes, but at the moment I really can't say.\r\n\r\nWhich places would this affect? Only all calls to `all_*` in `wcsapi/fitswcs.py`?\nYes I think that's right\nFor what it is worth, my comment is about the issues with the example. I think so far the history of `all_pix2world` shows that it is a very stable algorithm that converges for all \"real\" astronomical images. So, I wanted to learn about this failure. [NOTE: This does not mean that you should not catch exceptions in `pixel_to_world()` if you wish so.]\r\n\r\nThere are several issues with the example:\r\n1. Because `CTYPE` is not set, essentially the projection algorithm is linear, that is, intermediate physical coordinates are the world coordinates.\r\n2. SIP standard assumes that polynomials share the same CRPIX with the WCS. Here, CRPIX of the `Wcsprm` is `[0, 0]` while the CRPIX of the SIP is set to `[1221.87375165,  994.90917378]`\r\n3. If you run `wcs.all_pix2world(1, 1, 1)` you will get `[421.5126801, 374.13077558]` for world coordinates (and at CRPIX you will get CRVAL which is 0). This is in degrees. You can see that from the center pixel (CRPIX) to the corner of the image you are circling the celestial sphere many times (well, at least once; I did not check the other corners).\r\n\r\nIn summary, yes `all_world2pix` can fail but it does not imply that there is a bug in it. This example simply contains large distortions (like mapping `(1, 1) -> [421, 374]`) that cannot be handled with the currently implemented algorithm but I am not sure there is another algorithm that could do better.\r\n\r\nWith regard to throwing or not an exception... that's tough. On one hand, for those who are interested in correctness of the values, it is better to know that the algorithm failed and one cannot trust returned values. For plotting, this may be an issue and one would prefer to just get, maybe, the linear approximation. My personal preference is for exceptions because they can be caught and dealt with by the caller.\nThe example is a minimal version of our real WCS whichs nonlinear distortion is taken from a checkerboard image and it fits it quit well:\r\n![fitteddistortion](https://user-images.githubusercontent.com/64231/116892995-be892a00-ac30-11eb-826f-99e3635af1fa.png)\r\n\r\nThe WCS was fitted with `fit_wcs_from_points` using an artificial very small 'RA/DEC-TAN' grid so that it is almost linear.\r\n\r\nI guess the Problem is that the camera really has a huge distortion which just isn't fitable with a polynomial. Nevertheless it still is a real camera distortion, but I agree in that it probably is not worth to be considered a bug in the `all_world2pix` method.",
    "created_at": "2021-05-04T10:05:33Z",
    "patch": "<patch>\ndiff --git a/astropy/wcs/wcsapi/fitswcs.py b/astropy/wcs/wcsapi/fitswcs.py\n--- a/astropy/wcs/wcsapi/fitswcs.py\n+++ b/astropy/wcs/wcsapi/fitswcs.py\n@@ -323,7 +323,17 @@ def pixel_to_world_values(self, *pixel_arrays):\n         return world[0] if self.world_n_dim == 1 else tuple(world)\n \n     def world_to_pixel_values(self, *world_arrays):\n-        pixel = self.all_world2pix(*world_arrays, 0)\n+        # avoid circular import\n+        from astropy.wcs.wcs import NoConvergence\n+        try:\n+            pixel = self.all_world2pix(*world_arrays, 0)\n+        except NoConvergence as e:\n+            warnings.warn(str(e))\n+            # use best_solution contained in the exception and format the same\n+            # way as all_world2pix does (using _array_converter)\n+            pixel = self._array_converter(lambda *args: e.best_solution,\n+                                         'input', *world_arrays, 0)\n+\n         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n \n     @property\n\n</patch>",
    "test_patch": "diff --git a/astropy/wcs/wcsapi/tests/test_fitswcs.py b/astropy/wcs/wcsapi/tests/test_fitswcs.py\n--- a/astropy/wcs/wcsapi/tests/test_fitswcs.py\n+++ b/astropy/wcs/wcsapi/tests/test_fitswcs.py\n@@ -19,7 +19,7 @@\n from astropy.io.fits.verify import VerifyWarning\n from astropy.units.core import UnitsWarning\n from astropy.utils.data import get_pkg_data_filename\n-from astropy.wcs.wcs import WCS, FITSFixedWarning\n+from astropy.wcs.wcs import WCS, FITSFixedWarning, Sip, NoConvergence\n from astropy.wcs.wcsapi.fitswcs import custom_ctype_to_ucd_mapping, VELOCITY_FRAMES\n from astropy.wcs._wcs import __version__ as wcsver\n from astropy.utils import iers\n@@ -401,7 +401,7 @@ def test_spectral_cube_nonaligned():\n CRVAL3A = 2440.525 / Relative time of first frame\n CUNIT3A = 's' / Time unit\n CRPIX3A = 1.0 / Pixel coordinate at ref point\n-OBSGEO-B= -24.6157 / [deg] Tel geodetic latitude (=North)+\n+OBSGEO-B= -24.6157 / [deg] Tel geodetic latitute (=North)+\n OBSGEO-L= -70.3976 / [deg] Tel geodetic longitude (=East)+\n OBSGEO-H= 2530.0000 / [m] Tel height above reference ellipsoid\n CRDER3  = 0.0819 / random error in timings from fit\n@@ -1067,3 +1067,32 @@ def test_different_ctypes(header_spectral_frames, ctype3, observer):\n             pix = wcs.world_to_pixel(skycoord, spectralcoord)\n \n     assert_allclose(pix, [0, 0, 31], rtol=1e-6)\n+\n+\n+def test_non_convergence_warning():\n+    \"\"\"Test case for issue #11446\n+    Since we can't define a target accuracy when plotting a WCS `all_world2pix`\n+    should not error but only warn when the default accuracy can't be reached.\n+    \"\"\"\n+    # define a minimal WCS where convergence fails for certain image positions\n+    wcs = WCS(naxis=2)\n+    crpix = [0, 0]\n+    a = b = ap = bp = np.zeros((4, 4))\n+    a[3, 0] = -1.20116753e-07\n+\n+    test_pos_x = [1000, 1]\n+    test_pos_y = [0, 2]\n+\n+    wcs.sip = Sip(a, b, ap, bp, crpix)\n+    # first make sure the WCS works when using a low accuracy\n+    expected = wcs.all_world2pix(test_pos_x, test_pos_y, 0, tolerance=1e-3)\n+\n+    # then check that it fails when using the default accuracy\n+    with pytest.raises(NoConvergence):\n+        wcs.all_world2pix(test_pos_x, test_pos_y, 0)\n+\n+    # at last check that world_to_pixel_values raises a warning but returns\n+    # the same 'low accuray' result\n+    with pytest.warns(UserWarning):\n+        assert_allclose(wcs.world_to_pixel_values(test_pos_x, test_pos_y),\n+                        expected)\n",
    "version": "4.2",
    "FAIL_TO_PASS": "[\"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_non_convergence_warning\"]",
    "PASS_TO_PASS": "[\"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_empty\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_simple_celestial\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_values[tai]\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_values[tcb]\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_values[tcg]\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_values[tdb]\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_values[tt]\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_values[ut1]\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_values[utc]\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_values[local]\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_values_gps\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_values_deprecated\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_values_time\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_high_precision\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_location_geodetic\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_location_geocentric\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_location_geocenter\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_location_missing\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_location_incomplete\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_location_unsupported\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_time_1d_unsupported_ctype\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_unrecognized_unit\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_distortion_correlations\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_custom_ctype_to_ucd_mappings\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_caching_components_and_classes\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_sub_wcsapi_attributes\", \"astropy/wcs/wcsapi/tests/test_fitswcs.py::test_phys_type_polarization\"]",
    "environment_setup_commit": "3832210580d516365ddae1a62071001faf94d416",
    "file_names": [
        "README.rst",
        "astropy/wcs/wcsapi/fitswcs.py"
    ],
    "file_contents": [
        "=======\nAstropy\n=======\n\n|Actions Status| |CircleCI Status| |Azure Status| |Coverage Status| |PyPI Status| |Documentation Status| |Zenodo|\n\nThe Astropy Project (http://astropy.org/) is a community effort to develop a\nsingle core package for Astronomy in Python and foster interoperability between\nPython astronomy packages. This repository contains the core package which is\nintended to contain much of the core functionality and some common tools needed\nfor performing astronomy and astrophysics with Python.\n\nReleases are `registered on PyPI <https://pypi.org/project/astropy>`_,\nand development is occurring at the\n`project's GitHub page <http://github.com/astropy/astropy>`_.\n\nFor installation instructions, see the `online documentation <https://docs.astropy.org/>`_\nor  `docs/install.rst <docs/install.rst>`_ in this source distribution.\n\nContributing Code, Documentation, or Feedback\n---------------------------------------------\n\nThe Astropy Project is made both by and for its users, so we welcome and\nencourage contributions of many kinds. Our goal is to keep this a positive,\ninclusive, successful, and growing community by abiding with the\n`Astropy Community Code of Conduct <http://www.astropy.org/about.html#codeofconduct>`_.\n\nMore detailed information on contributing to the project or submitting feedback\ncan be found on the `contributions <http://www.astropy.org/contribute.html>`_\npage. A `summary of contribution guidelines <CONTRIBUTING.md>`_ can also be\nused as a quick reference when you are ready to start writing or validating\ncode for submission.\n\nSupporting the Project\n----------------------\n\n|NumFOCUS| |Donate|\n\nThe Astropy Project is sponsored by NumFOCUS, a 501(c)(3) nonprofit in the\nUnited States. You can donate to the project by using the link above, and this\ndonation will support our mission to promote sustainable, high-level code base\nfor the astronomy community, open code development, educational materials, and\nreproducible scientific research.\n\nLicense\n-------\n\nAstropy is licensed under a 3-clause BSD style license - see the\n`LICENSE.rst <LICENSE.rst>`_ file.\n\n.. |Actions Status| image:: https://github.com/astropy/astropy/workflows/CI/badge.svg\n    :target: https://github.com/astropy/astropy/actions\n    :alt: Astropy's GitHub Actions CI Status\n\n.. |CircleCI Status| image::  https://img.shields.io/circleci/build/github/astropy/astropy/main?logo=circleci&label=CircleCI\n    :target: https://circleci.com/gh/astropy/astropy\n    :alt: Astropy's CircleCI Status\n\n.. |Azure Status| image:: https://dev.azure.com/astropy-project/astropy/_apis/build/status/astropy.astropy?repoName=astropy%2Fastropy&branchName=main\n    :target: https://dev.azure.com/astropy-project/astropy\n    :alt: Astropy's Azure Pipelines Status\n\n.. |Coverage Status| image:: https://codecov.io/gh/astropy/astropy/branch/main/graph/badge.svg\n    :target: https://codecov.io/gh/astropy/astropy\n    :alt: Astropy's Coverage Status\n\n.. |PyPI Status| image:: https://img.shields.io/pypi/v/astropy.svg\n    :target: https://pypi.org/project/astropy\n    :alt: Astropy's PyPI Status\n\n.. |Zenodo| image:: https://zenodo.org/badge/DOI/10.5281/zenodo.4670728.svg\n   :target: https://doi.org/10.5281/zenodo.4670728\n   :alt: Zenodo DOI\n\n.. |Documentation Status| image:: https://img.shields.io/readthedocs/astropy/latest.svg?logo=read%20the%20docs&logoColor=white&label=Docs&version=stable\n    :target: https://docs.astropy.org/en/stable/?badge=stable\n    :alt: Documentation Status\n\n.. |NumFOCUS| image:: https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A\n    :target: http://numfocus.org\n    :alt: Powered by NumFOCUS\n\n.. |Donate| image:: https://img.shields.io/badge/Donate-to%20Astropy-brightgreen.svg\n    :target: https://numfocus.salsalabs.org/donate-to-astropy/index.html\n\n\nIf you locally cloned this repo before 7 Apr 2021\n-------------------------------------------------\n\nThe primary branch for this repo has been transitioned from ``master`` to\n``main``.  If you have a local clone of this repository and want to keep your\nlocal branch in sync with this repo, you'll need to do the following in your\nlocal clone from your terminal::\n\n   git fetch --all --prune\n   # you can stop here if you don't use your local \"master\"/\"main\" branch\n   git branch -m master main\n   git branch -u origin/main main\n\nIf you are using a GUI to manage your repos you'll have to find the equivalent\ncommands as it's different for different programs. Alternatively, you can just\ndelete your local clone and re-clone!",
        "# This file includes the definition of a mix-in class that provides the low-\n# and high-level WCS API to the astropy.wcs.WCS object. We keep this code\n# isolated in this mix-in class to avoid making the main wcs.py file too\n# long.\n\nimport warnings\n\nimport numpy as np\n\nfrom astropy import units as u\nfrom astropy.coordinates import SpectralCoord, Galactic, ICRS\nfrom astropy.coordinates.spectral_coordinate import update_differentials_to_match, attach_zero_velocities\nfrom astropy.utils.exceptions import AstropyUserWarning\nfrom astropy.constants import c\n\nfrom .low_level_api import BaseLowLevelWCS\nfrom .high_level_api import HighLevelWCSMixin\nfrom .wrappers import SlicedLowLevelWCS\n\n__all__ = ['custom_ctype_to_ucd_mapping', 'SlicedFITSWCS', 'FITSWCSAPIMixin']\n\nC_SI = c.si.value\n\nVELOCITY_FRAMES = {\n    'GEOCENT': 'gcrs',\n    'BARYCENT': 'icrs',\n    'HELIOCENT': 'hcrs',\n    'LSRK': 'lsrk',\n    'LSRD': 'lsrd'\n}\n\n# The spectra velocity frames below are needed for FITS spectral WCS\n#  (see Greisen 06 table 12) but aren't yet defined as real\n# astropy.coordinates frames, so we instead define them here as instances\n# of existing coordinate frames with offset velocities. In future we should\n# make these real frames so that users can more easily recognize these\n# velocity frames when used in SpectralCoord.\n\n# This frame is defined as a velocity of 220 km/s in the\n# direction of l=90, b=0. The rotation velocity is defined\n# in:\n#\n#   Kerr and Lynden-Bell 1986, Review of galactic constants.\n#\n# NOTE: this may differ from the assumptions of galcen_v_sun\n# in the Galactocentric frame - the value used here is\n# the one adopted by the WCS standard for spectral\n# transformations.\n\nVELOCITY_FRAMES['GALACTOC'] = Galactic(u=0 * u.km, v=0 * u.km, w=0 * u.km,\n                                       U=0 * u.km / u.s, V=-220 * u.km / u.s, W=0 * u.km / u.s,\n                                       representation_type='cartesian',\n                                       differential_type='cartesian')\n\n# This frame is defined as a velocity of 300 km/s in the\n# direction of l=90, b=0. This is defined in:\n#\n#   Transactions of the IAU Vol. XVI B Proceedings of the\n#   16th General Assembly, Reports of Meetings of Commissions:\n#   Comptes Rendus Des Séances Des Commissions, Commission 28,\n#   p201.\n#\n# Note that these values differ from those used by CASA\n# (308 km/s towards l=105, b=-7) but we use the above values\n# since these are the ones defined in Greisen et al (2006).\n\nVELOCITY_FRAMES['LOCALGRP'] = Galactic(u=0 * u.km, v=0 * u.km, w=0 * u.km,\n                                       U=0 * u.km / u.s, V=-300 * u.km / u.s, W=0 * u.km / u.s,\n                                       representation_type='cartesian',\n                                       differential_type='cartesian')\n\n# This frame is defined as a velocity of 368 km/s in the\n# direction of l=263.85, b=48.25. This is defined in:\n#\n#   Bennett et al. (2003), First-Year Wilkinson Microwave\n#   Anisotropy Probe (WMAP) Observations: Preliminary Maps\n#   and Basic Results\n#\n# Note that in that paper, the dipole is expressed as a\n# temperature (T=3.346 +/- 0.017mK)\n\nVELOCITY_FRAMES['CMBDIPOL'] = Galactic(l=263.85 * u.deg, b=48.25 * u.deg, distance=0 * u.km,\n                                       radial_velocity=-(3.346e-3 / 2.725 * c).to(u.km/u.s))\n\n\n# Mapping from CTYPE axis name to UCD1\n\nCTYPE_TO_UCD1 = {\n\n    # Celestial coordinates\n    'RA': 'pos.eq.ra',\n    'DEC': 'pos.eq.dec',\n    'GLON': 'pos.galactic.lon',\n    'GLAT': 'pos.galactic.lat',\n    'ELON': 'pos.ecliptic.lon',\n    'ELAT': 'pos.ecliptic.lat',\n    'TLON': 'pos.bodyrc.lon',\n    'TLAT': 'pos.bodyrc.lat',\n    'HPLT': 'custom:pos.helioprojective.lat',\n    'HPLN': 'custom:pos.helioprojective.lon',\n    'HPRZ': 'custom:pos.helioprojective.z',\n    'HGLN': 'custom:pos.heliographic.stonyhurst.lon',\n    'HGLT': 'custom:pos.heliographic.stonyhurst.lat',\n    'CRLN': 'custom:pos.heliographic.carrington.lon',\n    'CRLT': 'custom:pos.heliographic.carrington.lat',\n    'SOLX': 'custom:pos.heliocentric.x',\n    'SOLY': 'custom:pos.heliocentric.y',\n    'SOLZ': 'custom:pos.heliocentric.z',\n\n    # Spectral coordinates (WCS paper 3)\n    'FREQ': 'em.freq',  # Frequency\n    'ENER': 'em.energy',  # Energy\n    'WAVN': 'em.wavenumber',  # Wavenumber\n    'WAVE': 'em.wl',  # Vacuum wavelength\n    'VRAD': 'spect.dopplerVeloc.radio',  # Radio velocity\n    'VOPT': 'spect.dopplerVeloc.opt',  # Optical velocity\n    'ZOPT': 'src.redshift',  # Redshift\n    'AWAV': 'em.wl',  # Air wavelength\n    'VELO': 'spect.dopplerVeloc',  # Apparent radial velocity\n    'BETA': 'custom:spect.doplerVeloc.beta',  # Beta factor (v/c)\n    'STOKES': 'phys.polarization.stokes',  # STOKES parameters\n\n    # Time coordinates (https://www.aanda.org/articles/aa/pdf/2015/02/aa24653-14.pdf)\n    'TIME': 'time',\n    'TAI': 'time',\n    'TT': 'time',\n    'TDT': 'time',\n    'ET': 'time',\n    'IAT': 'time',\n    'UT1': 'time',\n    'UTC': 'time',\n    'GMT': 'time',\n    'GPS': 'time',\n    'TCG': 'time',\n    'TCB': 'time',\n    'TDB': 'time',\n    'LOCAL': 'time',\n\n    # Distance coordinates\n    'DIST': 'pos.distance',\n    'DSUN': 'custom:pos.distance.sunToObserver'\n\n    # UT() and TT() are handled separately in world_axis_physical_types\n\n}\n\n# Keep a list of additional custom mappings that have been registered. This\n# is kept as a list in case nested context managers are used\nCTYPE_TO_UCD1_CUSTOM = []\n\n\nclass custom_ctype_to_ucd_mapping:\n    \"\"\"\n    A context manager that makes it possible to temporarily add new CTYPE to\n    UCD1+ mapping used by :attr:`FITSWCSAPIMixin.world_axis_physical_types`.\n\n    Parameters\n    ----------\n    mapping : dict\n        A dictionary mapping a CTYPE value to a UCD1+ value\n\n    Examples\n    --------\n\n    Consider a WCS with the following CTYPE::\n\n        >>> from astropy.wcs import WCS\n        >>> wcs = WCS(naxis=1)\n        >>> wcs.wcs.ctype = ['SPAM']\n\n    By default, :attr:`FITSWCSAPIMixin.world_axis_physical_types` returns `None`,\n    but this can be overridden::\n\n        >>> wcs.world_axis_physical_types\n        [None]\n        >>> with custom_ctype_to_ucd_mapping({'SPAM': 'food.spam'}):\n        ...     wcs.world_axis_physical_types\n        ['food.spam']\n    \"\"\"\n\n    def __init__(self, mapping):\n        CTYPE_TO_UCD1_CUSTOM.insert(0, mapping)\n        self.mapping = mapping\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, type, value, tb):\n        CTYPE_TO_UCD1_CUSTOM.remove(self.mapping)\n\n\nclass SlicedFITSWCS(SlicedLowLevelWCS, HighLevelWCSMixin):\n    pass\n\n\nclass FITSWCSAPIMixin(BaseLowLevelWCS, HighLevelWCSMixin):\n    \"\"\"\n    A mix-in class that is intended to be inherited by the\n    :class:`~astropy.wcs.WCS` class and provides the low- and high-level WCS API\n    \"\"\"\n\n    @property\n    def pixel_n_dim(self):\n        return self.naxis\n\n    @property\n    def world_n_dim(self):\n        return len(self.wcs.ctype)\n\n    @property\n    def array_shape(self):\n        if self.pixel_shape is None:\n            return None\n        else:\n            return self.pixel_shape[::-1]\n\n    @array_shape.setter\n    def array_shape(self, value):\n        if value is None:\n            self.pixel_shape = None\n        else:\n            self.pixel_shape = value[::-1]\n\n    @property\n    def pixel_shape(self):\n        if self._naxis == [0, 0]:\n            return None\n        else:\n            return tuple(self._naxis)\n\n    @pixel_shape.setter\n    def pixel_shape(self, value):\n        if value is None:\n            self._naxis = [0, 0]\n        else:\n            if len(value) != self.naxis:\n                raise ValueError(\"The number of data axes, \"\n                                 \"{}, does not equal the \"\n                                 \"shape {}.\".format(self.naxis, len(value)))\n            self._naxis = list(value)\n\n    @property\n    def pixel_bounds(self):\n        return self._pixel_bounds\n\n    @pixel_bounds.setter\n    def pixel_bounds(self, value):\n        if value is None:\n            self._pixel_bounds = value\n        else:\n            if len(value) != self.naxis:\n                raise ValueError(\"The number of data axes, \"\n                                 \"{}, does not equal the number of \"\n                                 \"pixel bounds {}.\".format(self.naxis, len(value)))\n            self._pixel_bounds = list(value)\n\n    @property\n    def world_axis_physical_types(self):\n        types = []\n        # TODO: need to support e.g. TT(TAI)\n        for ctype in self.wcs.ctype:\n            if ctype.upper().startswith(('UT(', 'TT(')):\n                types.append('time')\n            else:\n                ctype_name = ctype.split('-')[0]\n                for custom_mapping in CTYPE_TO_UCD1_CUSTOM:\n                    if ctype_name in custom_mapping:\n                        types.append(custom_mapping[ctype_name])\n                        break\n                else:\n                    types.append(CTYPE_TO_UCD1.get(ctype_name.upper(), None))\n        return types\n\n    @property\n    def world_axis_units(self):\n        units = []\n        for unit in self.wcs.cunit:\n            if unit is None:\n                unit = ''\n            elif isinstance(unit, u.Unit):\n                unit = unit.to_string(format='vounit')\n            else:\n                try:\n                    unit = u.Unit(unit).to_string(format='vounit')\n                except u.UnitsError:\n                    unit = ''\n            units.append(unit)\n        return units\n\n    @property\n    def world_axis_names(self):\n        return list(self.wcs.cname)\n\n    @property\n    def axis_correlation_matrix(self):\n\n        # If there are any distortions present, we assume that there may be\n        # correlations between all axes. Maybe if some distortions only apply\n        # to the image plane we can improve this?\n        if self.has_distortion:\n            return np.ones((self.world_n_dim, self.pixel_n_dim), dtype=bool)\n\n        # Assuming linear world coordinates along each axis, the correlation\n        # matrix would be given by whether or not the PC matrix is zero\n        matrix = self.wcs.get_pc() != 0\n\n        # We now need to check specifically for celestial coordinates since\n        # these can assume correlations because of spherical distortions. For\n        # each celestial coordinate we copy over the pixel dependencies from\n        # the other celestial coordinates.\n        celestial = (self.wcs.axis_types // 1000) % 10 == 2\n        celestial_indices = np.nonzero(celestial)[0]\n        for world1 in celestial_indices:\n            for world2 in celestial_indices:\n                if world1 != world2:\n                    matrix[world1] |= matrix[world2]\n                    matrix[world2] |= matrix[world1]\n\n        return matrix\n\n    def pixel_to_world_values(self, *pixel_arrays):\n        world = self.all_pix2world(*pixel_arrays, 0)\n        return world[0] if self.world_n_dim == 1 else tuple(world)\n\n    def world_to_pixel_values(self, *world_arrays):\n        pixel = self.all_world2pix(*world_arrays, 0)\n        return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n\n    @property\n    def world_axis_object_components(self):\n        return self._get_components_and_classes()[0]\n\n    @property\n    def world_axis_object_classes(self):\n        return self._get_components_and_classes()[1]\n\n    @property\n    def serialized_classes(self):\n        return False\n\n    def _get_components_and_classes(self):\n\n        # The aim of this function is to return whatever is needed for\n        # world_axis_object_components and world_axis_object_classes. It's easier\n        # to figure it out in one go and then return the values and let the\n        # properties return part of it.\n\n        # Since this method might get called quite a few times, we need to cache\n        # it. We start off by defining a hash based on the attributes of the\n        # WCS that matter here (we can't just use the WCS object as a hash since\n        # it is mutable)\n        wcs_hash = (self.naxis,\n                    list(self.wcs.ctype),\n                    list(self.wcs.cunit),\n                    self.wcs.radesys,\n                    self.wcs.specsys,\n                    self.wcs.equinox,\n                    self.wcs.dateobs,\n                    self.wcs.lng,\n                    self.wcs.lat)\n\n        # If the cache is present, we need to check that the 'hash' matches.\n        if getattr(self, '_components_and_classes_cache', None) is not None:\n            cache = self._components_and_classes_cache\n            if cache[0] == wcs_hash:\n                return cache[1]\n            else:\n                self._components_and_classes_cache = None\n\n        # Avoid circular imports by importing here\n        from astropy.wcs.utils import wcs_to_celestial_frame\n        from astropy.coordinates import SkyCoord, EarthLocation\n        from astropy.time.formats import FITS_DEPRECATED_SCALES\n        from astropy.time import Time, TimeDelta\n\n        components = [None] * self.naxis\n        classes = {}\n\n        # Let's start off by checking whether the WCS has a pair of celestial\n        # components\n\n        if self.has_celestial:\n\n            try:\n                celestial_frame = wcs_to_celestial_frame(self)\n            except ValueError:\n                # Some WCSes, e.g. solar, can be recognized by WCSLIB as being\n                # celestial but we don't necessarily have frames for them.\n                celestial_frame = None\n            else:\n\n                kwargs = {}\n                kwargs['frame'] = celestial_frame\n                kwargs['unit'] = u.deg\n\n                classes['celestial'] = (SkyCoord, (), kwargs)\n\n                components[self.wcs.lng] = ('celestial', 0, 'spherical.lon.degree')\n                components[self.wcs.lat] = ('celestial', 1, 'spherical.lat.degree')\n\n        # Next, we check for spectral components\n\n        if self.has_spectral:\n\n            # Find index of spectral coordinate\n            ispec = self.wcs.spec\n            ctype = self.wcs.ctype[ispec][:4]\n            ctype = ctype.upper()\n\n            kwargs = {}\n\n            # Determine observer location and velocity\n\n            # TODO: determine how WCS standard would deal with observer on a\n            # spacecraft far from earth. For now assume the obsgeo parameters,\n            # if present, give the geocentric observer location.\n\n            if np.isnan(self.wcs.obsgeo[0]):\n                observer = None\n            else:\n\n                earth_location = EarthLocation(*self.wcs.obsgeo[:3], unit=u.m)\n                obstime = Time(self.wcs.mjdobs, format='mjd', scale='utc',\n                               location=earth_location)\n                observer_location = SkyCoord(earth_location.get_itrs(obstime=obstime))\n\n                if self.wcs.specsys in VELOCITY_FRAMES:\n                    frame = VELOCITY_FRAMES[self.wcs.specsys]\n                    observer = observer_location.transform_to(frame)\n                    if isinstance(frame, str):\n                        observer = attach_zero_velocities(observer)\n                    else:\n                        observer = update_differentials_to_match(observer_location,\n                                                                 VELOCITY_FRAMES[self.wcs.specsys],\n                                                                 preserve_observer_frame=True)\n                elif self.wcs.specsys == 'TOPOCENT':\n                    observer = attach_zero_velocities(observer_location)\n                else:\n                    raise NotImplementedError(f'SPECSYS={self.wcs.specsys} not yet supported')\n\n            # Determine target\n\n            # This is tricker. In principle the target for each pixel is the\n            # celestial coordinates of the pixel, but we then need to be very\n            # careful about SSYSOBS which is tricky. For now, we set the\n            # target using the reference celestial coordinate in the WCS (if\n            # any).\n\n            if self.has_celestial and celestial_frame is not None:\n\n                # NOTE: celestial_frame was defined higher up\n\n                # NOTE: we set the distance explicitly to avoid warnings in SpectralCoord\n\n                target = SkyCoord(self.wcs.crval[self.wcs.lng] * self.wcs.cunit[self.wcs.lng],\n                                  self.wcs.crval[self.wcs.lat] * self.wcs.cunit[self.wcs.lat],\n                                  frame=celestial_frame,\n                                  distance=1000 * u.kpc)\n\n                target = attach_zero_velocities(target)\n\n            else:\n\n                target = None\n\n            # SpectralCoord does not work properly if either observer or target\n            # are not convertible to ICRS, so if this is the case, we (for now)\n            # drop the observer and target from the SpectralCoord and warn the\n            # user.\n\n            if observer is not None:\n                try:\n                    observer.transform_to(ICRS())\n                except Exception:\n                    warnings.warn('observer cannot be converted to ICRS, so will '\n                                  'not be set on SpectralCoord', AstropyUserWarning)\n                    observer = None\n\n            if target is not None:\n                try:\n                    target.transform_to(ICRS())\n                except Exception:\n                    warnings.warn('target cannot be converted to ICRS, so will '\n                                  'not be set on SpectralCoord', AstropyUserWarning)\n                    target = None\n\n            # NOTE: below we include Quantity in classes['spectral'] instead\n            # of SpectralCoord - this is because we want to also be able to\n            # accept plain quantities.\n\n            if ctype == 'ZOPT':\n\n                def spectralcoord_from_redshift(redshift):\n                    if isinstance(redshift, SpectralCoord):\n                        return redshift\n                    return SpectralCoord((redshift + 1) * self.wcs.restwav,\n                                         unit=u.m, observer=observer, target=target)\n\n                def redshift_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(u.m) / self.wcs.restwav - 1.\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(u.m) / self.wcs.restwav - 1.\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_redshift)\n                components[self.wcs.spec] = ('spectral', 0, redshift_from_spectralcoord)\n\n            elif ctype == 'BETA':\n\n                def spectralcoord_from_beta(beta):\n                    if isinstance(beta, SpectralCoord):\n                        return beta\n                    return SpectralCoord(beta * C_SI,\n                                         unit=u.m / u.s,\n                                         doppler_convention='relativistic',\n                                         doppler_rest=self.wcs.restwav * u.m,\n                                         observer=observer, target=target)\n\n                def beta_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    doppler_equiv = u.doppler_relativistic(self.wcs.restwav * u.m)\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(u.m / u.s, doppler_equiv) / C_SI\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(u.m / u.s, doppler_equiv) / C_SI\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_beta)\n                components[self.wcs.spec] = ('spectral', 0, beta_from_spectralcoord)\n\n            else:\n\n                kwargs['unit'] = self.wcs.cunit[ispec]\n\n                if self.wcs.restfrq > 0:\n                    if ctype == 'VELO':\n                        kwargs['doppler_convention'] = 'relativistic'\n                        kwargs['doppler_rest'] = self.wcs.restfrq * u.Hz\n                    elif ctype == 'VRAD':\n                        kwargs['doppler_convention'] = 'radio'\n                        kwargs['doppler_rest'] = self.wcs.restfrq * u.Hz\n                    elif ctype == 'VOPT':\n                        kwargs['doppler_convention'] = 'optical'\n                        kwargs['doppler_rest'] = self.wcs.restwav * u.m\n\n                def spectralcoord_from_value(value):\n                    return SpectralCoord(value, observer=observer, target=target, **kwargs)\n\n                def value_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(**kwargs)\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(**kwargs)\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_value)\n                components[self.wcs.spec] = ('spectral', 0, value_from_spectralcoord)\n\n        # We can then make sure we correctly return Time objects where appropriate\n        # (https://www.aanda.org/articles/aa/pdf/2015/02/aa24653-14.pdf)\n\n        if 'time' in self.world_axis_physical_types:\n\n            multiple_time = self.world_axis_physical_types.count('time') > 1\n\n            for i in range(self.naxis):\n\n                if self.world_axis_physical_types[i] == 'time':\n\n                    if multiple_time:\n                        name = f'time.{i}'\n                    else:\n                        name = 'time'\n\n                    # Initialize delta\n                    reference_time_delta = None\n\n                    # Extract time scale\n                    scale = self.wcs.ctype[i].lower()\n\n                    if scale == 'time':\n                        if self.wcs.timesys:\n                            scale = self.wcs.timesys.lower()\n                        else:\n                            scale = 'utc'\n\n                    # Drop sub-scales\n                    if '(' in scale:\n                        pos = scale.index('(')\n                        scale, subscale = scale[:pos], scale[pos+1:-1]\n                        warnings.warn(f'Dropping unsupported sub-scale '\n                                      f'{subscale.upper()} from scale {scale.upper()}',\n                                      UserWarning)\n\n                    # TODO: consider having GPS as a scale in Time\n                    # For now GPS is not a scale, we approximate this by TAI - 19s\n                    if scale == 'gps':\n                        reference_time_delta = TimeDelta(19, format='sec')\n                        scale = 'tai'\n\n                    elif scale.upper() in FITS_DEPRECATED_SCALES:\n                        scale = FITS_DEPRECATED_SCALES[scale.upper()]\n\n                    elif scale not in Time.SCALES:\n                        raise ValueError(f'Unrecognized time CTYPE={self.wcs.ctype[i]}')\n\n                    # Determine location\n                    trefpos = self.wcs.trefpos.lower()\n\n                    if trefpos.startswith('topocent'):\n                        # Note that some headers use TOPOCENT instead of TOPOCENTER\n                        if np.any(np.isnan(self.wcs.obsgeo[:3])):\n                            warnings.warn('Missing or incomplete observer location '\n                                          'information, setting location in Time to None',\n                                          UserWarning)\n                            location = None\n                        else:\n                            location = EarthLocation(*self.wcs.obsgeo[:3], unit=u.m)\n                    elif trefpos == 'geocenter':\n                        location = EarthLocation(0, 0, 0, unit=u.m)\n                    elif trefpos == '':\n                        location = None\n                    else:\n                        # TODO: implement support for more locations when Time supports it\n                        warnings.warn(f\"Observation location '{trefpos}' is not \"\n                                       \"supported, setting location in Time to None\", UserWarning)\n                        location = None\n\n                    reference_time = Time(np.nan_to_num(self.wcs.mjdref[0]),\n                                          np.nan_to_num(self.wcs.mjdref[1]),\n                                          format='mjd', scale=scale,\n                                          location=location)\n\n                    if reference_time_delta is not None:\n                        reference_time = reference_time + reference_time_delta\n\n                    def time_from_reference_and_offset(offset):\n                        if isinstance(offset, Time):\n                            return offset\n                        return reference_time + TimeDelta(offset, format='sec')\n\n                    def offset_from_time_and_reference(time):\n                        return (time - reference_time).sec\n\n                    classes[name] = (Time, (), {}, time_from_reference_and_offset)\n                    components[i] = (name, 0, offset_from_time_and_reference)\n\n        # Fallback: for any remaining components that haven't been identified, just\n        # return Quantity as the class to use\n\n        for i in range(self.naxis):\n            if components[i] is None:\n                name = self.wcs.ctype[i].split('-')[0].lower()\n                if name == '':\n                    name = 'world'\n                while name in classes:\n                    name += \"_\"\n                classes[name] = (u.Quantity, (), {'unit': self.wcs.cunit[i]})\n                components[i] = (name, 0, 'value')\n\n        # Keep a cached version of result\n        self._components_and_classes_cache = wcs_hash, (components, classes)\n\n        return components, classes"
    ],
    "qwen_input_length": 12034,
    "data_source": "swe-oracle-search-replace",
    "prompt": [
        {
            "content": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\n'WCS.all_world2pix' failed to converge when plotting WCS with non linear distortions\n<!-- This comments are hidden when you submit the issue,\r\nso you do not need to remove them! -->\r\n\r\n<!-- Please be sure to check out our contributing guidelines,\r\nhttps://github.com/astropy/astropy/blob/master/CONTRIBUTING.md .\r\nPlease be sure to check out our code of conduct,\r\nhttps://github.com/astropy/astropy/blob/master/CODE_OF_CONDUCT.md . -->\r\n\r\n<!-- Please have a search on our GitHub repository to see if a similar\r\nissue has already been posted.\r\nIf a similar issue is closed, have a quick look to see if you are satisfied\r\nby the resolution.\r\nIf not please go ahead and open an issue! -->\r\n\r\n<!-- Please check that the development version still produces the same bug.\r\nYou can install development version with\r\npip install git+https://github.com/astropy/astropy\r\ncommand. -->\r\n\r\n### Description\r\nWhen trying to plot an image with a WCS as projection that contains non linear Distortions it fails with a `NoConvergence` error.\r\n\r\n### Expected behavior\r\nWhen I add `quiet=True` as parameter to the call \r\n```pixel = self.all_world2pix(*world_arrays, 0)``` \r\nat line 326 of `astropy/wcs/wcsapi/fitswcs.py` I get the good enough looking plot below:\r\n\r\n![bugreport](https://user-images.githubusercontent.com/64231/112940287-37c2c800-912d-11eb-8ce8-56fd284bb8e7.png)\r\n\r\nIt would be nice if there was a way of getting that plot without having to hack the library code like that.\r\n### Actual behavior\r\n<!-- What actually happened. -->\r\n<!-- Was the output confusing or poorly described? -->\r\nThe call to plotting the grid fails with the following error (last few lines, can provide more if necessary):\r\n\r\n```\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcsapi/fitswcs.py in world_to_pixel_values(self, *world_arrays)\r\n    324 \r\n    325     def world_to_pixel_values(self, *world_arrays):\r\n--> 326         pixel = self.all_world2pix(*world_arrays, 0)\r\n    327         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\r\n    328 \r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/utils/decorators.py in wrapper(*args, **kwargs)\r\n    534                     warnings.warn(message, warning_type, stacklevel=2)\r\n    535 \r\n--> 536             return function(*args, **kwargs)\r\n    537 \r\n    538         return wrapper\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in all_world2pix(self, tolerance, maxiter, adaptive, detect_divergence, quiet, *args, **kwargs)\r\n   1886             raise ValueError(\"No basic WCS settings were created.\")\r\n   1887 \r\n-> 1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n   1890             self._all_world2pix(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _array_converter(self, func, sky, ra_dec_order, *args)\r\n   1335                     \"a 1-D array for each axis, followed by an origin.\")\r\n   1336 \r\n-> 1337             return _return_list_of_arrays(axes, origin)\r\n   1338 \r\n   1339         raise TypeError(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _return_list_of_arrays(axes, origin)\r\n   1289             if ra_dec_order and sky == 'input':\r\n   1290                 xy = self._denormalize_sky(xy)\r\n-> 1291             output = func(xy, origin)\r\n   1292             if ra_dec_order and sky == 'output':\r\n   1293                 output = self._normalize_sky(output)\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in <lambda>(*args, **kwargs)\r\n   1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n-> 1890             self._all_world2pix(\r\n   1891                 *args, tolerance=tolerance, maxiter=maxiter,\r\n   1892                 adaptive=adaptive, detect_divergence=detect_divergence,\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _all_world2pix(self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet)\r\n   1869                     slow_conv=ind, divergent=None)\r\n   1870             else:\r\n-> 1871                 raise NoConvergence(\r\n   1872                     \"'WCS.all_world2pix' failed to \"\r\n   1873                     \"converge to the requested accuracy.\\n\"\r\n\r\nNoConvergence: 'WCS.all_world2pix' failed to converge to the requested accuracy.\r\nAfter 20 iterations, the solution is diverging at least for one input point.\r\n```\r\n\r\n### Steps to Reproduce\r\n<!-- Ideally a code example could be provided so we can run it ourselves. -->\r\n<!-- If you are pasting code, use triple backticks (```) around\r\nyour code snippet. -->\r\n<!-- If necessary, sanitize your screen output to be pasted so you do not\r\nreveal secrets like tokens and passwords. -->\r\n\r\nHere is the code to reproduce the problem:\r\n```\r\nfrom astropy.wcs import WCS, Sip\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nwcs = WCS(naxis=2)\r\na = [[ 0.00000000e+00,  0.00000000e+00,  6.77532513e-07,\r\n        -1.76632141e-10],\r\n       [ 0.00000000e+00,  9.49130161e-06, -1.50614321e-07,\r\n         0.00000000e+00],\r\n       [ 7.37260409e-06,  2.07020239e-09,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [-1.20116753e-07,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\nb = [[ 0.00000000e+00,  0.00000000e+00,  1.34606617e-05,\r\n        -1.41919055e-07],\r\n       [ 0.00000000e+00,  5.85158316e-06, -1.10382462e-09,\r\n         0.00000000e+00],\r\n       [ 1.06306407e-05, -1.36469008e-07,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [ 3.27391123e-09,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\ncrpix = [1221.87375165,  994.90917378]\r\nap = bp = np.zeros((4, 4))\r\n\r\nwcs.sip = Sip(a, b, ap, bp, crpix)\r\n\r\nplt.subplot(projection=wcs)\r\nplt.imshow(np.zeros((1944, 2592)))\r\nplt.grid(color='white', ls='solid')\r\n```\r\n\r\n### System Details\r\n<!-- Even if you do not think this is necessary, it is useful information for the maintainers.\r\nPlease run the following snippet and paste the output below:\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"Numpy\", numpy.__version__)\r\nimport astropy; print(\"astropy\", astropy.__version__)\r\nimport scipy; print(\"Scipy\", scipy.__version__)\r\nimport matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\n-->\r\n```\r\n>>> import platform; print(platform.platform())\r\nLinux-5.11.10-arch1-1-x86_64-with-glibc2.33\r\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.9.2 (default, Feb 20 2021, 18:40:11) \r\n[GCC 10.2.0]\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.20.2\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 4.3.dev690+g7811614f8\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.6.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.3.4\r\n```\n'WCS.all_world2pix' failed to converge when plotting WCS with non linear distortions\n<!-- This comments are hidden when you submit the issue,\r\nso you do not need to remove them! -->\r\n\r\n<!-- Please be sure to check out our contributing guidelines,\r\nhttps://github.com/astropy/astropy/blob/master/CONTRIBUTING.md .\r\nPlease be sure to check out our code of conduct,\r\nhttps://github.com/astropy/astropy/blob/master/CODE_OF_CONDUCT.md . -->\r\n\r\n<!-- Please have a search on our GitHub repository to see if a similar\r\nissue has already been posted.\r\nIf a similar issue is closed, have a quick look to see if you are satisfied\r\nby the resolution.\r\nIf not please go ahead and open an issue! -->\r\n\r\n<!-- Please check that the development version still produces the same bug.\r\nYou can install development version with\r\npip install git+https://github.com/astropy/astropy\r\ncommand. -->\r\n\r\n### Description\r\nWhen trying to plot an image with a WCS as projection that contains non linear Distortions it fails with a `NoConvergence` error.\r\n\r\n### Expected behavior\r\nWhen I add `quiet=True` as parameter to the call \r\n```pixel = self.all_world2pix(*world_arrays, 0)``` \r\nat line 326 of `astropy/wcs/wcsapi/fitswcs.py` I get the good enough looking plot below:\r\n\r\n![bugreport](https://user-images.githubusercontent.com/64231/112940287-37c2c800-912d-11eb-8ce8-56fd284bb8e7.png)\r\n\r\nIt would be nice if there was a way of getting that plot without having to hack the library code like that.\r\n### Actual behavior\r\n<!-- What actually happened. -->\r\n<!-- Was the output confusing or poorly described? -->\r\nThe call to plotting the grid fails with the following error (last few lines, can provide more if necessary):\r\n\r\n```\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcsapi/fitswcs.py in world_to_pixel_values(self, *world_arrays)\r\n    324 \r\n    325     def world_to_pixel_values(self, *world_arrays):\r\n--> 326         pixel = self.all_world2pix(*world_arrays, 0)\r\n    327         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\r\n    328 \r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/utils/decorators.py in wrapper(*args, **kwargs)\r\n    534                     warnings.warn(message, warning_type, stacklevel=2)\r\n    535 \r\n--> 536             return function(*args, **kwargs)\r\n    537 \r\n    538         return wrapper\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in all_world2pix(self, tolerance, maxiter, adaptive, detect_divergence, quiet, *args, **kwargs)\r\n   1886             raise ValueError(\"No basic WCS settings were created.\")\r\n   1887 \r\n-> 1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n   1890             self._all_world2pix(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _array_converter(self, func, sky, ra_dec_order, *args)\r\n   1335                     \"a 1-D array for each axis, followed by an origin.\")\r\n   1336 \r\n-> 1337             return _return_list_of_arrays(axes, origin)\r\n   1338 \r\n   1339         raise TypeError(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _return_list_of_arrays(axes, origin)\r\n   1289             if ra_dec_order and sky == 'input':\r\n   1290                 xy = self._denormalize_sky(xy)\r\n-> 1291             output = func(xy, origin)\r\n   1292             if ra_dec_order and sky == 'output':\r\n   1293                 output = self._normalize_sky(output)\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in <lambda>(*args, **kwargs)\r\n   1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n-> 1890             self._all_world2pix(\r\n   1891                 *args, tolerance=tolerance, maxiter=maxiter,\r\n   1892                 adaptive=adaptive, detect_divergence=detect_divergence,\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _all_world2pix(self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet)\r\n   1869                     slow_conv=ind, divergent=None)\r\n   1870             else:\r\n-> 1871                 raise NoConvergence(\r\n   1872                     \"'WCS.all_world2pix' failed to \"\r\n   1873                     \"converge to the requested accuracy.\\n\"\r\n\r\nNoConvergence: 'WCS.all_world2pix' failed to converge to the requested accuracy.\r\nAfter 20 iterations, the solution is diverging at least for one input point.\r\n```\r\n\r\n### Steps to Reproduce\r\n<!-- Ideally a code example could be provided so we can run it ourselves. -->\r\n<!-- If you are pasting code, use triple backticks (```) around\r\nyour code snippet. -->\r\n<!-- If necessary, sanitize your screen output to be pasted so you do not\r\nreveal secrets like tokens and passwords. -->\r\n\r\nHere is the code to reproduce the problem:\r\n```\r\nfrom astropy.wcs import WCS, Sip\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nwcs = WCS(naxis=2)\r\na = [[ 0.00000000e+00,  0.00000000e+00,  6.77532513e-07,\r\n        -1.76632141e-10],\r\n       [ 0.00000000e+00,  9.49130161e-06, -1.50614321e-07,\r\n         0.00000000e+00],\r\n       [ 7.37260409e-06,  2.07020239e-09,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [-1.20116753e-07,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\nb = [[ 0.00000000e+00,  0.00000000e+00,  1.34606617e-05,\r\n        -1.41919055e-07],\r\n       [ 0.00000000e+00,  5.85158316e-06, -1.10382462e-09,\r\n         0.00000000e+00],\r\n       [ 1.06306407e-05, -1.36469008e-07,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [ 3.27391123e-09,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\ncrpix = [1221.87375165,  994.90917378]\r\nap = bp = np.zeros((4, 4))\r\n\r\nwcs.sip = Sip(a, b, ap, bp, crpix)\r\n\r\nplt.subplot(projection=wcs)\r\nplt.imshow(np.zeros((1944, 2592)))\r\nplt.grid(color='white', ls='solid')\r\n```\r\n\r\n### System Details\r\n<!-- Even if you do not think this is necessary, it is useful information for the maintainers.\r\nPlease run the following snippet and paste the output below:\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"Numpy\", numpy.__version__)\r\nimport astropy; print(\"astropy\", astropy.__version__)\r\nimport scipy; print(\"Scipy\", scipy.__version__)\r\nimport matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\n-->\r\n```\r\n>>> import platform; print(platform.platform())\r\nLinux-5.11.10-arch1-1-x86_64-with-glibc2.33\r\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.9.2 (default, Feb 20 2021, 18:40:11) \r\n[GCC 10.2.0]\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.20.2\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 4.3.dev690+g7811614f8\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.6.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.3.4\r\n```\n\n--- END ISSUE ---\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### README.rst\n=======\nAstropy\n=======\n\n|Actions Status| |CircleCI Status| |Azure Status| |Coverage Status| |PyPI Status| |Documentation Status| |Zenodo|\n\nThe Astropy Project (http://astropy.org/) is a community effort to develop a\nsingle core package for Astronomy in Python and foster interoperability between\nPython astronomy packages. This repository contains the core package which is\nintended to contain much of the core functionality and some common tools needed\nfor performing astronomy and astrophysics with Python.\n\nReleases are `registered on PyPI <https://pypi.org/project/astropy>`_,\nand development is occurring at the\n`project's GitHub page <http://github.com/astropy/astropy>`_.\n\nFor installation instructions, see the `online documentation <https://docs.astropy.org/>`_\nor  `docs/install.rst <docs/install.rst>`_ in this source distribution.\n\nContributing Code, Documentation, or Feedback\n---------------------------------------------\n\nThe Astropy Project is made both by and for its users, so we welcome and\nencourage contributions of many kinds. Our goal is to keep this a positive,\ninclusive, successful, and growing community by abiding with the\n`Astropy Community Code of Conduct <http://www.astropy.org/about.html#codeofconduct>`_.\n\nMore detailed information on contributing to the project or submitting feedback\ncan be found on the `contributions <http://www.astropy.org/contribute.html>`_\npage. A `summary of contribution guidelines <CONTRIBUTING.md>`_ can also be\nused as a quick reference when you are ready to start writing or validating\ncode for submission.\n\nSupporting the Project\n----------------------\n\n|NumFOCUS| |Donate|\n\nThe Astropy Project is sponsored by NumFOCUS, a 501(c)(3) nonprofit in the\nUnited States. You can donate to the project by using the link above, and this\ndonation will support our mission to promote sustainable, high-level code base\nfor the astronomy community, open code development, educational materials, and\nreproducible scientific research.\n\nLicense\n-------\n\nAstropy is licensed under a 3-clause BSD style license - see the\n`LICENSE.rst <LICENSE.rst>`_ file.\n\n.. |Actions Status| image:: https://github.com/astropy/astropy/workflows/CI/badge.svg\n    :target: https://github.com/astropy/astropy/actions\n    :alt: Astropy's GitHub Actions CI Status\n\n.. |CircleCI Status| image::  https://img.shields.io/circleci/build/github/astropy/astropy/main?logo=circleci&label=CircleCI\n    :target: https://circleci.com/gh/astropy/astropy\n    :alt: Astropy's CircleCI Status\n\n.. |Azure Status| image:: https://dev.azure.com/astropy-project/astropy/_apis/build/status/astropy.astropy?repoName=astropy%2Fastropy&branchName=main\n    :target: https://dev.azure.com/astropy-project/astropy\n    :alt: Astropy's Azure Pipelines Status\n\n.. |Coverage Status| image:: https://codecov.io/gh/astropy/astropy/branch/main/graph/badge.svg\n    :target: https://codecov.io/gh/astropy/astropy\n    :alt: Astropy's Coverage Status\n\n.. |PyPI Status| image:: https://img.shields.io/pypi/v/astropy.svg\n    :target: https://pypi.org/project/astropy\n    :alt: Astropy's PyPI Status\n\n.. |Zenodo| image:: https://zenodo.org/badge/DOI/10.5281/zenodo.4670728.svg\n   :target: https://doi.org/10.5281/zenodo.4670728\n   :alt: Zenodo DOI\n\n.. |Documentation Status| image:: https://img.shields.io/readthedocs/astropy/latest.svg?logo=read%20the%20docs&logoColor=white&label=Docs&version=stable\n    :target: https://docs.astropy.org/en/stable/?badge=stable\n    :alt: Documentation Status\n\n.. |NumFOCUS| image:: https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A\n    :target: http://numfocus.org\n    :alt: Powered by NumFOCUS\n\n.. |Donate| image:: https://img.shields.io/badge/Donate-to%20Astropy-brightgreen.svg\n    :target: https://numfocus.salsalabs.org/donate-to-astropy/index.html\n\n\nIf you locally cloned this repo before 7 Apr 2021\n-------------------------------------------------\n\nThe primary branch for this repo has been transitioned from ``master`` to\n``main``.  If you have a local clone of this repository and want to keep your\nlocal branch in sync with this repo, you'll need to do the following in your\nlocal clone from your terminal::\n\n   git fetch --all --prune\n   # you can stop here if you don't use your local \"master\"/\"main\" branch\n   git branch -m master main\n   git branch -u origin/main main\n\nIf you are using a GUI to manage your repos you'll have to find the equivalent\ncommands as it's different for different programs. Alternatively, you can just\ndelete your local clone and re-clone!\n\n### astropy/wcs/wcsapi/fitswcs.py\n# This file includes the definition of a mix-in class that provides the low-\n# and high-level WCS API to the astropy.wcs.WCS object. We keep this code\n# isolated in this mix-in class to avoid making the main wcs.py file too\n# long.\n\nimport warnings\n\nimport numpy as np\n\nfrom astropy import units as u\nfrom astropy.coordinates import SpectralCoord, Galactic, ICRS\nfrom astropy.coordinates.spectral_coordinate import update_differentials_to_match, attach_zero_velocities\nfrom astropy.utils.exceptions import AstropyUserWarning\nfrom astropy.constants import c\n\nfrom .low_level_api import BaseLowLevelWCS\nfrom .high_level_api import HighLevelWCSMixin\nfrom .wrappers import SlicedLowLevelWCS\n\n__all__ = ['custom_ctype_to_ucd_mapping', 'SlicedFITSWCS', 'FITSWCSAPIMixin']\n\nC_SI = c.si.value\n\nVELOCITY_FRAMES = {\n    'GEOCENT': 'gcrs',\n    'BARYCENT': 'icrs',\n    'HELIOCENT': 'hcrs',\n    'LSRK': 'lsrk',\n    'LSRD': 'lsrd'\n}\n\n# The spectra velocity frames below are needed for FITS spectral WCS\n#  (see Greisen 06 table 12) but aren't yet defined as real\n# astropy.coordinates frames, so we instead define them here as instances\n# of existing coordinate frames with offset velocities. In future we should\n# make these real frames so that users can more easily recognize these\n# velocity frames when used in SpectralCoord.\n\n# This frame is defined as a velocity of 220 km/s in the\n# direction of l=90, b=0. The rotation velocity is defined\n# in:\n#\n#   Kerr and Lynden-Bell 1986, Review of galactic constants.\n#\n# NOTE: this may differ from the assumptions of galcen_v_sun\n# in the Galactocentric frame - the value used here is\n# the one adopted by the WCS standard for spectral\n# transformations.\n\nVELOCITY_FRAMES['GALACTOC'] = Galactic(u=0 * u.km, v=0 * u.km, w=0 * u.km,\n                                       U=0 * u.km / u.s, V=-220 * u.km / u.s, W=0 * u.km / u.s,\n                                       representation_type='cartesian',\n                                       differential_type='cartesian')\n\n# This frame is defined as a velocity of 300 km/s in the\n# direction of l=90, b=0. This is defined in:\n#\n#   Transactions of the IAU Vol. XVI B Proceedings of the\n#   16th General Assembly, Reports of Meetings of Commissions:\n#   Comptes Rendus Des Séances Des Commissions, Commission 28,\n#   p201.\n#\n# Note that these values differ from those used by CASA\n# (308 km/s towards l=105, b=-7) but we use the above values\n# since these are the ones defined in Greisen et al (2006).\n\nVELOCITY_FRAMES['LOCALGRP'] = Galactic(u=0 * u.km, v=0 * u.km, w=0 * u.km,\n                                       U=0 * u.km / u.s, V=-300 * u.km / u.s, W=0 * u.km / u.s,\n                                       representation_type='cartesian',\n                                       differential_type='cartesian')\n\n# This frame is defined as a velocity of 368 km/s in the\n# direction of l=263.85, b=48.25. This is defined in:\n#\n#   Bennett et al. (2003), First-Year Wilkinson Microwave\n#   Anisotropy Probe (WMAP) Observations: Preliminary Maps\n#   and Basic Results\n#\n# Note that in that paper, the dipole is expressed as a\n# temperature (T=3.346 +/- 0.017mK)\n\nVELOCITY_FRAMES['CMBDIPOL'] = Galactic(l=263.85 * u.deg, b=48.25 * u.deg, distance=0 * u.km,\n                                       radial_velocity=-(3.346e-3 / 2.725 * c).to(u.km/u.s))\n\n\n# Mapping from CTYPE axis name to UCD1\n\nCTYPE_TO_UCD1 = {\n\n    # Celestial coordinates\n    'RA': 'pos.eq.ra',\n    'DEC': 'pos.eq.dec',\n    'GLON': 'pos.galactic.lon',\n    'GLAT': 'pos.galactic.lat',\n    'ELON': 'pos.ecliptic.lon',\n    'ELAT': 'pos.ecliptic.lat',\n    'TLON': 'pos.bodyrc.lon',\n    'TLAT': 'pos.bodyrc.lat',\n    'HPLT': 'custom:pos.helioprojective.lat',\n    'HPLN': 'custom:pos.helioprojective.lon',\n    'HPRZ': 'custom:pos.helioprojective.z',\n    'HGLN': 'custom:pos.heliographic.stonyhurst.lon',\n    'HGLT': 'custom:pos.heliographic.stonyhurst.lat',\n    'CRLN': 'custom:pos.heliographic.carrington.lon',\n    'CRLT': 'custom:pos.heliographic.carrington.lat',\n    'SOLX': 'custom:pos.heliocentric.x',\n    'SOLY': 'custom:pos.heliocentric.y',\n    'SOLZ': 'custom:pos.heliocentric.z',\n\n    # Spectral coordinates (WCS paper 3)\n    'FREQ': 'em.freq',  # Frequency\n    'ENER': 'em.energy',  # Energy\n    'WAVN': 'em.wavenumber',  # Wavenumber\n    'WAVE': 'em.wl',  # Vacuum wavelength\n    'VRAD': 'spect.dopplerVeloc.radio',  # Radio velocity\n    'VOPT': 'spect.dopplerVeloc.opt',  # Optical velocity\n    'ZOPT': 'src.redshift',  # Redshift\n    'AWAV': 'em.wl',  # Air wavelength\n    'VELO': 'spect.dopplerVeloc',  # Apparent radial velocity\n    'BETA': 'custom:spect.doplerVeloc.beta',  # Beta factor (v/c)\n    'STOKES': 'phys.polarization.stokes',  # STOKES parameters\n\n    # Time coordinates (https://www.aanda.org/articles/aa/pdf/2015/02/aa24653-14.pdf)\n    'TIME': 'time',\n    'TAI': 'time',\n    'TT': 'time',\n    'TDT': 'time',\n    'ET': 'time',\n    'IAT': 'time',\n    'UT1': 'time',\n    'UTC': 'time',\n    'GMT': 'time',\n    'GPS': 'time',\n    'TCG': 'time',\n    'TCB': 'time',\n    'TDB': 'time',\n    'LOCAL': 'time',\n\n    # Distance coordinates\n    'DIST': 'pos.distance',\n    'DSUN': 'custom:pos.distance.sunToObserver'\n\n    # UT() and TT() are handled separately in world_axis_physical_types\n\n}\n\n# Keep a list of additional custom mappings that have been registered. This\n# is kept as a list in case nested context managers are used\nCTYPE_TO_UCD1_CUSTOM = []\n\n\nclass custom_ctype_to_ucd_mapping:\n    \"\"\"\n    A context manager that makes it possible to temporarily add new CTYPE to\n    UCD1+ mapping used by :attr:`FITSWCSAPIMixin.world_axis_physical_types`.\n\n    Parameters\n    ----------\n    mapping : dict\n        A dictionary mapping a CTYPE value to a UCD1+ value\n\n    Examples\n    --------\n\n    Consider a WCS with the following CTYPE::\n\n        >>> from astropy.wcs import WCS\n        >>> wcs = WCS(naxis=1)\n        >>> wcs.wcs.ctype = ['SPAM']\n\n    By default, :attr:`FITSWCSAPIMixin.world_axis_physical_types` returns `None`,\n    but this can be overridden::\n\n        >>> wcs.world_axis_physical_types\n        [None]\n        >>> with custom_ctype_to_ucd_mapping({'SPAM': 'food.spam'}):\n        ...     wcs.world_axis_physical_types\n        ['food.spam']\n    \"\"\"\n\n    def __init__(self, mapping):\n        CTYPE_TO_UCD1_CUSTOM.insert(0, mapping)\n        self.mapping = mapping\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, type, value, tb):\n        CTYPE_TO_UCD1_CUSTOM.remove(self.mapping)\n\n\nclass SlicedFITSWCS(SlicedLowLevelWCS, HighLevelWCSMixin):\n    pass\n\n\nclass FITSWCSAPIMixin(BaseLowLevelWCS, HighLevelWCSMixin):\n    \"\"\"\n    A mix-in class that is intended to be inherited by the\n    :class:`~astropy.wcs.WCS` class and provides the low- and high-level WCS API\n    \"\"\"\n\n    @property\n    def pixel_n_dim(self):\n        return self.naxis\n\n    @property\n    def world_n_dim(self):\n        return len(self.wcs.ctype)\n\n    @property\n    def array_shape(self):\n        if self.pixel_shape is None:\n            return None\n        else:\n            return self.pixel_shape[::-1]\n\n    @array_shape.setter\n    def array_shape(self, value):\n        if value is None:\n            self.pixel_shape = None\n        else:\n            self.pixel_shape = value[::-1]\n\n    @property\n    def pixel_shape(self):\n        if self._naxis == [0, 0]:\n            return None\n        else:\n            return tuple(self._naxis)\n\n    @pixel_shape.setter\n    def pixel_shape(self, value):\n        if value is None:\n            self._naxis = [0, 0]\n        else:\n            if len(value) != self.naxis:\n                raise ValueError(\"The number of data axes, \"\n                                 \"{}, does not equal the \"\n                                 \"shape {}.\".format(self.naxis, len(value)))\n            self._naxis = list(value)\n\n    @property\n    def pixel_bounds(self):\n        return self._pixel_bounds\n\n    @pixel_bounds.setter\n    def pixel_bounds(self, value):\n        if value is None:\n            self._pixel_bounds = value\n        else:\n            if len(value) != self.naxis:\n                raise ValueError(\"The number of data axes, \"\n                                 \"{}, does not equal the number of \"\n                                 \"pixel bounds {}.\".format(self.naxis, len(value)))\n            self._pixel_bounds = list(value)\n\n    @property\n    def world_axis_physical_types(self):\n        types = []\n        # TODO: need to support e.g. TT(TAI)\n        for ctype in self.wcs.ctype:\n            if ctype.upper().startswith(('UT(', 'TT(')):\n                types.append('time')\n            else:\n                ctype_name = ctype.split('-')[0]\n                for custom_mapping in CTYPE_TO_UCD1_CUSTOM:\n                    if ctype_name in custom_mapping:\n                        types.append(custom_mapping[ctype_name])\n                        break\n                else:\n                    types.append(CTYPE_TO_UCD1.get(ctype_name.upper(), None))\n        return types\n\n    @property\n    def world_axis_units(self):\n        units = []\n        for unit in self.wcs.cunit:\n            if unit is None:\n                unit = ''\n            elif isinstance(unit, u.Unit):\n                unit = unit.to_string(format='vounit')\n            else:\n                try:\n                    unit = u.Unit(unit).to_string(format='vounit')\n                except u.UnitsError:\n                    unit = ''\n            units.append(unit)\n        return units\n\n    @property\n    def world_axis_names(self):\n        return list(self.wcs.cname)\n\n    @property\n    def axis_correlation_matrix(self):\n\n        # If there are any distortions present, we assume that there may be\n        # correlations between all axes. Maybe if some distortions only apply\n        # to the image plane we can improve this?\n        if self.has_distortion:\n            return np.ones((self.world_n_dim, self.pixel_n_dim), dtype=bool)\n\n        # Assuming linear world coordinates along each axis, the correlation\n        # matrix would be given by whether or not the PC matrix is zero\n        matrix = self.wcs.get_pc() != 0\n\n        # We now need to check specifically for celestial coordinates since\n        # these can assume correlations because of spherical distortions. For\n        # each celestial coordinate we copy over the pixel dependencies from\n        # the other celestial coordinates.\n        celestial = (self.wcs.axis_types // 1000) % 10 == 2\n        celestial_indices = np.nonzero(celestial)[0]\n        for world1 in celestial_indices:\n            for world2 in celestial_indices:\n                if world1 != world2:\n                    matrix[world1] |= matrix[world2]\n                    matrix[world2] |= matrix[world1]\n\n        return matrix\n\n    def pixel_to_world_values(self, *pixel_arrays):\n        world = self.all_pix2world(*pixel_arrays, 0)\n        return world[0] if self.world_n_dim == 1 else tuple(world)\n\n    def world_to_pixel_values(self, *world_arrays):\n        pixel = self.all_world2pix(*world_arrays, 0)\n        return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n\n    @property\n    def world_axis_object_components(self):\n        return self._get_components_and_classes()[0]\n\n    @property\n    def world_axis_object_classes(self):\n        return self._get_components_and_classes()[1]\n\n    @property\n    def serialized_classes(self):\n        return False\n\n    def _get_components_and_classes(self):\n\n        # The aim of this function is to return whatever is needed for\n        # world_axis_object_components and world_axis_object_classes. It's easier\n        # to figure it out in one go and then return the values and let the\n        # properties return part of it.\n\n        # Since this method might get called quite a few times, we need to cache\n        # it. We start off by defining a hash based on the attributes of the\n        # WCS that matter here (we can't just use the WCS object as a hash since\n        # it is mutable)\n        wcs_hash = (self.naxis,\n                    list(self.wcs.ctype),\n                    list(self.wcs.cunit),\n                    self.wcs.radesys,\n                    self.wcs.specsys,\n                    self.wcs.equinox,\n                    self.wcs.dateobs,\n                    self.wcs.lng,\n                    self.wcs.lat)\n\n        # If the cache is present, we need to check that the 'hash' matches.\n        if getattr(self, '_components_and_classes_cache', None) is not None:\n            cache = self._components_and_classes_cache\n            if cache[0] == wcs_hash:\n                return cache[1]\n            else:\n                self._components_and_classes_cache = None\n\n        # Avoid circular imports by importing here\n        from astropy.wcs.utils import wcs_to_celestial_frame\n        from astropy.coordinates import SkyCoord, EarthLocation\n        from astropy.time.formats import FITS_DEPRECATED_SCALES\n        from astropy.time import Time, TimeDelta\n\n        components = [None] * self.naxis\n        classes = {}\n\n        # Let's start off by checking whether the WCS has a pair of celestial\n        # components\n\n        if self.has_celestial:\n\n            try:\n                celestial_frame = wcs_to_celestial_frame(self)\n            except ValueError:\n                # Some WCSes, e.g. solar, can be recognized by WCSLIB as being\n                # celestial but we don't necessarily have frames for them.\n                celestial_frame = None\n            else:\n\n                kwargs = {}\n                kwargs['frame'] = celestial_frame\n                kwargs['unit'] = u.deg\n\n                classes['celestial'] = (SkyCoord, (), kwargs)\n\n                components[self.wcs.lng] = ('celestial', 0, 'spherical.lon.degree')\n                components[self.wcs.lat] = ('celestial', 1, 'spherical.lat.degree')\n\n        # Next, we check for spectral components\n\n        if self.has_spectral:\n\n            # Find index of spectral coordinate\n            ispec = self.wcs.spec\n            ctype = self.wcs.ctype[ispec][:4]\n            ctype = ctype.upper()\n\n            kwargs = {}\n\n            # Determine observer location and velocity\n\n            # TODO: determine how WCS standard would deal with observer on a\n            # spacecraft far from earth. For now assume the obsgeo parameters,\n            # if present, give the geocentric observer location.\n\n            if np.isnan(self.wcs.obsgeo[0]):\n                observer = None\n            else:\n\n                earth_location = EarthLocation(*self.wcs.obsgeo[:3], unit=u.m)\n                obstime = Time(self.wcs.mjdobs, format='mjd', scale='utc',\n                               location=earth_location)\n                observer_location = SkyCoord(earth_location.get_itrs(obstime=obstime))\n\n                if self.wcs.specsys in VELOCITY_FRAMES:\n                    frame = VELOCITY_FRAMES[self.wcs.specsys]\n                    observer = observer_location.transform_to(frame)\n                    if isinstance(frame, str):\n                        observer = attach_zero_velocities(observer)\n                    else:\n                        observer = update_differentials_to_match(observer_location,\n                                                                 VELOCITY_FRAMES[self.wcs.specsys],\n                                                                 preserve_observer_frame=True)\n                elif self.wcs.specsys == 'TOPOCENT':\n                    observer = attach_zero_velocities(observer_location)\n                else:\n                    raise NotImplementedError(f'SPECSYS={self.wcs.specsys} not yet supported')\n\n            # Determine target\n\n            # This is tricker. In principle the target for each pixel is the\n            # celestial coordinates of the pixel, but we then need to be very\n            # careful about SSYSOBS which is tricky. For now, we set the\n            # target using the reference celestial coordinate in the WCS (if\n            # any).\n\n            if self.has_celestial and celestial_frame is not None:\n\n                # NOTE: celestial_frame was defined higher up\n\n                # NOTE: we set the distance explicitly to avoid warnings in SpectralCoord\n\n                target = SkyCoord(self.wcs.crval[self.wcs.lng] * self.wcs.cunit[self.wcs.lng],\n                                  self.wcs.crval[self.wcs.lat] * self.wcs.cunit[self.wcs.lat],\n                                  frame=celestial_frame,\n                                  distance=1000 * u.kpc)\n\n                target = attach_zero_velocities(target)\n\n            else:\n\n                target = None\n\n            # SpectralCoord does not work properly if either observer or target\n            # are not convertible to ICRS, so if this is the case, we (for now)\n            # drop the observer and target from the SpectralCoord and warn the\n            # user.\n\n            if observer is not None:\n                try:\n                    observer.transform_to(ICRS())\n                except Exception:\n                    warnings.warn('observer cannot be converted to ICRS, so will '\n                                  'not be set on SpectralCoord', AstropyUserWarning)\n                    observer = None\n\n            if target is not None:\n                try:\n                    target.transform_to(ICRS())\n                except Exception:\n                    warnings.warn('target cannot be converted to ICRS, so will '\n                                  'not be set on SpectralCoord', AstropyUserWarning)\n                    target = None\n\n            # NOTE: below we include Quantity in classes['spectral'] instead\n            # of SpectralCoord - this is because we want to also be able to\n            # accept plain quantities.\n\n            if ctype == 'ZOPT':\n\n                def spectralcoord_from_redshift(redshift):\n                    if isinstance(redshift, SpectralCoord):\n                        return redshift\n                    return SpectralCoord((redshift + 1) * self.wcs.restwav,\n                                         unit=u.m, observer=observer, target=target)\n\n                def redshift_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(u.m) / self.wcs.restwav - 1.\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(u.m) / self.wcs.restwav - 1.\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_redshift)\n                components[self.wcs.spec] = ('spectral', 0, redshift_from_spectralcoord)\n\n            elif ctype == 'BETA':\n\n                def spectralcoord_from_beta(beta):\n                    if isinstance(beta, SpectralCoord):\n                        return beta\n                    return SpectralCoord(beta * C_SI,\n                                         unit=u.m / u.s,\n                                         doppler_convention='relativistic',\n                                         doppler_rest=self.wcs.restwav * u.m,\n                                         observer=observer, target=target)\n\n                def beta_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    doppler_equiv = u.doppler_relativistic(self.wcs.restwav * u.m)\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(u.m / u.s, doppler_equiv) / C_SI\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(u.m / u.s, doppler_equiv) / C_SI\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_beta)\n                components[self.wcs.spec] = ('spectral', 0, beta_from_spectralcoord)\n\n            else:\n\n                kwargs['unit'] = self.wcs.cunit[ispec]\n\n                if self.wcs.restfrq > 0:\n                    if ctype == 'VELO':\n                        kwargs['doppler_convention'] = 'relativistic'\n                        kwargs['doppler_rest'] = self.wcs.restfrq * u.Hz\n                    elif ctype == 'VRAD':\n                        kwargs['doppler_convention'] = 'radio'\n                        kwargs['doppler_rest'] = self.wcs.restfrq * u.Hz\n                    elif ctype == 'VOPT':\n                        kwargs['doppler_convention'] = 'optical'\n                        kwargs['doppler_rest'] = self.wcs.restwav * u.m\n\n                def spectralcoord_from_value(value):\n                    return SpectralCoord(value, observer=observer, target=target, **kwargs)\n\n                def value_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(**kwargs)\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(**kwargs)\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_value)\n                components[self.wcs.spec] = ('spectral', 0, value_from_spectralcoord)\n\n        # We can then make sure we correctly return Time objects where appropriate\n        # (https://www.aanda.org/articles/aa/pdf/2015/02/aa24653-14.pdf)\n\n        if 'time' in self.world_axis_physical_types:\n\n            multiple_time = self.world_axis_physical_types.count('time') > 1\n\n            for i in range(self.naxis):\n\n                if self.world_axis_physical_types[i] == 'time':\n\n                    if multiple_time:\n                        name = f'time.{i}'\n                    else:\n                        name = 'time'\n\n                    # Initialize delta\n                    reference_time_delta = None\n\n                    # Extract time scale\n                    scale = self.wcs.ctype[i].lower()\n\n                    if scale == 'time':\n                        if self.wcs.timesys:\n                            scale = self.wcs.timesys.lower()\n                        else:\n                            scale = 'utc'\n\n                    # Drop sub-scales\n                    if '(' in scale:\n                        pos = scale.index('(')\n                        scale, subscale = scale[:pos], scale[pos+1:-1]\n                        warnings.warn(f'Dropping unsupported sub-scale '\n                                      f'{subscale.upper()} from scale {scale.upper()}',\n                                      UserWarning)\n\n                    # TODO: consider having GPS as a scale in Time\n                    # For now GPS is not a scale, we approximate this by TAI - 19s\n                    if scale == 'gps':\n                        reference_time_delta = TimeDelta(19, format='sec')\n                        scale = 'tai'\n\n                    elif scale.upper() in FITS_DEPRECATED_SCALES:\n                        scale = FITS_DEPRECATED_SCALES[scale.upper()]\n\n                    elif scale not in Time.SCALES:\n                        raise ValueError(f'Unrecognized time CTYPE={self.wcs.ctype[i]}')\n\n                    # Determine location\n                    trefpos = self.wcs.trefpos.lower()\n\n                    if trefpos.startswith('topocent'):\n                        # Note that some headers use TOPOCENT instead of TOPOCENTER\n                        if np.any(np.isnan(self.wcs.obsgeo[:3])):\n                            warnings.warn('Missing or incomplete observer location '\n                                          'information, setting location in Time to None',\n                                          UserWarning)\n                            location = None\n                        else:\n                            location = EarthLocation(*self.wcs.obsgeo[:3], unit=u.m)\n                    elif trefpos == 'geocenter':\n                        location = EarthLocation(0, 0, 0, unit=u.m)\n                    elif trefpos == '':\n                        location = None\n                    else:\n                        # TODO: implement support for more locations when Time supports it\n                        warnings.warn(f\"Observation location '{trefpos}' is not \"\n                                       \"supported, setting location in Time to None\", UserWarning)\n                        location = None\n\n                    reference_time = Time(np.nan_to_num(self.wcs.mjdref[0]),\n                                          np.nan_to_num(self.wcs.mjdref[1]),\n                                          format='mjd', scale=scale,\n                                          location=location)\n\n                    if reference_time_delta is not None:\n                        reference_time = reference_time + reference_time_delta\n\n                    def time_from_reference_and_offset(offset):\n                        if isinstance(offset, Time):\n                            return offset\n                        return reference_time + TimeDelta(offset, format='sec')\n\n                    def offset_from_time_and_reference(time):\n                        return (time - reference_time).sec\n\n                    classes[name] = (Time, (), {}, time_from_reference_and_offset)\n                    components[i] = (name, 0, offset_from_time_and_reference)\n\n        # Fallback: for any remaining components that haven't been identified, just\n        # return Quantity as the class to use\n\n        for i in range(self.naxis):\n            if components[i] is None:\n                name = self.wcs.ctype[i].split('-')[0].lower()\n                if name == '':\n                    name = 'world'\n                while name in classes:\n                    name += \"_\"\n                classes[name] = (u.Quantity, (), {'unit': self.wcs.cunit[i]})\n                components[i] = (name, 0, 'value')\n\n        # Keep a cached version of result\n        self._components_and_classes_cache = wcs_hash, (components, classes)\n\n        return components, classes\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap each *SEARCH/REPLACE* edit in a code block as shown in the example above. If you have multiple *SEARCH/REPLACE* edits, use a separate code block for each one.\n\nYour response format must follow the template below:\n<think>\nYour thoughts or/and draft, like working through an exercise on scratch paper. Be as casual and as long as you want until you are confident to generate a correct solution.\n</think>\n<solution>\none or multiple SEARCH/REPLACE edits in code blocks.\n</solution>",
            "role": "user"
        }
    ],
    "ability": "swe",
    "reward_model": {
        "ground_truth": [
            [
                "README.rst",
                "astropy/wcs/wcsapi/fitswcs.py"
            ],
            [
                "=======\nAstropy\n=======\n\n|Actions Status| |CircleCI Status| |Azure Status| |Coverage Status| |PyPI Status| |Documentation Status| |Zenodo|\n\nThe Astropy Project (http://astropy.org/) is a community effort to develop a\nsingle core package for Astronomy in Python and foster interoperability between\nPython astronomy packages. This repository contains the core package which is\nintended to contain much of the core functionality and some common tools needed\nfor performing astronomy and astrophysics with Python.\n\nReleases are `registered on PyPI <https://pypi.org/project/astropy>`_,\nand development is occurring at the\n`project's GitHub page <http://github.com/astropy/astropy>`_.\n\nFor installation instructions, see the `online documentation <https://docs.astropy.org/>`_\nor  `docs/install.rst <docs/install.rst>`_ in this source distribution.\n\nContributing Code, Documentation, or Feedback\n---------------------------------------------\n\nThe Astropy Project is made both by and for its users, so we welcome and\nencourage contributions of many kinds. Our goal is to keep this a positive,\ninclusive, successful, and growing community by abiding with the\n`Astropy Community Code of Conduct <http://www.astropy.org/about.html#codeofconduct>`_.\n\nMore detailed information on contributing to the project or submitting feedback\ncan be found on the `contributions <http://www.astropy.org/contribute.html>`_\npage. A `summary of contribution guidelines <CONTRIBUTING.md>`_ can also be\nused as a quick reference when you are ready to start writing or validating\ncode for submission.\n\nSupporting the Project\n----------------------\n\n|NumFOCUS| |Donate|\n\nThe Astropy Project is sponsored by NumFOCUS, a 501(c)(3) nonprofit in the\nUnited States. You can donate to the project by using the link above, and this\ndonation will support our mission to promote sustainable, high-level code base\nfor the astronomy community, open code development, educational materials, and\nreproducible scientific research.\n\nLicense\n-------\n\nAstropy is licensed under a 3-clause BSD style license - see the\n`LICENSE.rst <LICENSE.rst>`_ file.\n\n.. |Actions Status| image:: https://github.com/astropy/astropy/workflows/CI/badge.svg\n    :target: https://github.com/astropy/astropy/actions\n    :alt: Astropy's GitHub Actions CI Status\n\n.. |CircleCI Status| image::  https://img.shields.io/circleci/build/github/astropy/astropy/main?logo=circleci&label=CircleCI\n    :target: https://circleci.com/gh/astropy/astropy\n    :alt: Astropy's CircleCI Status\n\n.. |Azure Status| image:: https://dev.azure.com/astropy-project/astropy/_apis/build/status/astropy.astropy?repoName=astropy%2Fastropy&branchName=main\n    :target: https://dev.azure.com/astropy-project/astropy\n    :alt: Astropy's Azure Pipelines Status\n\n.. |Coverage Status| image:: https://codecov.io/gh/astropy/astropy/branch/main/graph/badge.svg\n    :target: https://codecov.io/gh/astropy/astropy\n    :alt: Astropy's Coverage Status\n\n.. |PyPI Status| image:: https://img.shields.io/pypi/v/astropy.svg\n    :target: https://pypi.org/project/astropy\n    :alt: Astropy's PyPI Status\n\n.. |Zenodo| image:: https://zenodo.org/badge/DOI/10.5281/zenodo.4670728.svg\n   :target: https://doi.org/10.5281/zenodo.4670728\n   :alt: Zenodo DOI\n\n.. |Documentation Status| image:: https://img.shields.io/readthedocs/astropy/latest.svg?logo=read%20the%20docs&logoColor=white&label=Docs&version=stable\n    :target: https://docs.astropy.org/en/stable/?badge=stable\n    :alt: Documentation Status\n\n.. |NumFOCUS| image:: https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A\n    :target: http://numfocus.org\n    :alt: Powered by NumFOCUS\n\n.. |Donate| image:: https://img.shields.io/badge/Donate-to%20Astropy-brightgreen.svg\n    :target: https://numfocus.salsalabs.org/donate-to-astropy/index.html\n\n\nIf you locally cloned this repo before 7 Apr 2021\n-------------------------------------------------\n\nThe primary branch for this repo has been transitioned from ``master`` to\n``main``.  If you have a local clone of this repository and want to keep your\nlocal branch in sync with this repo, you'll need to do the following in your\nlocal clone from your terminal::\n\n   git fetch --all --prune\n   # you can stop here if you don't use your local \"master\"/\"main\" branch\n   git branch -m master main\n   git branch -u origin/main main\n\nIf you are using a GUI to manage your repos you'll have to find the equivalent\ncommands as it's different for different programs. Alternatively, you can just\ndelete your local clone and re-clone!",
                "# This file includes the definition of a mix-in class that provides the low-\n# and high-level WCS API to the astropy.wcs.WCS object. We keep this code\n# isolated in this mix-in class to avoid making the main wcs.py file too\n# long.\n\nimport warnings\n\nimport numpy as np\n\nfrom astropy import units as u\nfrom astropy.coordinates import SpectralCoord, Galactic, ICRS\nfrom astropy.coordinates.spectral_coordinate import update_differentials_to_match, attach_zero_velocities\nfrom astropy.utils.exceptions import AstropyUserWarning\nfrom astropy.constants import c\n\nfrom .low_level_api import BaseLowLevelWCS\nfrom .high_level_api import HighLevelWCSMixin\nfrom .wrappers import SlicedLowLevelWCS\n\n__all__ = ['custom_ctype_to_ucd_mapping', 'SlicedFITSWCS', 'FITSWCSAPIMixin']\n\nC_SI = c.si.value\n\nVELOCITY_FRAMES = {\n    'GEOCENT': 'gcrs',\n    'BARYCENT': 'icrs',\n    'HELIOCENT': 'hcrs',\n    'LSRK': 'lsrk',\n    'LSRD': 'lsrd'\n}\n\n# The spectra velocity frames below are needed for FITS spectral WCS\n#  (see Greisen 06 table 12) but aren't yet defined as real\n# astropy.coordinates frames, so we instead define them here as instances\n# of existing coordinate frames with offset velocities. In future we should\n# make these real frames so that users can more easily recognize these\n# velocity frames when used in SpectralCoord.\n\n# This frame is defined as a velocity of 220 km/s in the\n# direction of l=90, b=0. The rotation velocity is defined\n# in:\n#\n#   Kerr and Lynden-Bell 1986, Review of galactic constants.\n#\n# NOTE: this may differ from the assumptions of galcen_v_sun\n# in the Galactocentric frame - the value used here is\n# the one adopted by the WCS standard for spectral\n# transformations.\n\nVELOCITY_FRAMES['GALACTOC'] = Galactic(u=0 * u.km, v=0 * u.km, w=0 * u.km,\n                                       U=0 * u.km / u.s, V=-220 * u.km / u.s, W=0 * u.km / u.s,\n                                       representation_type='cartesian',\n                                       differential_type='cartesian')\n\n# This frame is defined as a velocity of 300 km/s in the\n# direction of l=90, b=0. This is defined in:\n#\n#   Transactions of the IAU Vol. XVI B Proceedings of the\n#   16th General Assembly, Reports of Meetings of Commissions:\n#   Comptes Rendus Des Séances Des Commissions, Commission 28,\n#   p201.\n#\n# Note that these values differ from those used by CASA\n# (308 km/s towards l=105, b=-7) but we use the above values\n# since these are the ones defined in Greisen et al (2006).\n\nVELOCITY_FRAMES['LOCALGRP'] = Galactic(u=0 * u.km, v=0 * u.km, w=0 * u.km,\n                                       U=0 * u.km / u.s, V=-300 * u.km / u.s, W=0 * u.km / u.s,\n                                       representation_type='cartesian',\n                                       differential_type='cartesian')\n\n# This frame is defined as a velocity of 368 km/s in the\n# direction of l=263.85, b=48.25. This is defined in:\n#\n#   Bennett et al. (2003), First-Year Wilkinson Microwave\n#   Anisotropy Probe (WMAP) Observations: Preliminary Maps\n#   and Basic Results\n#\n# Note that in that paper, the dipole is expressed as a\n# temperature (T=3.346 +/- 0.017mK)\n\nVELOCITY_FRAMES['CMBDIPOL'] = Galactic(l=263.85 * u.deg, b=48.25 * u.deg, distance=0 * u.km,\n                                       radial_velocity=-(3.346e-3 / 2.725 * c).to(u.km/u.s))\n\n\n# Mapping from CTYPE axis name to UCD1\n\nCTYPE_TO_UCD1 = {\n\n    # Celestial coordinates\n    'RA': 'pos.eq.ra',\n    'DEC': 'pos.eq.dec',\n    'GLON': 'pos.galactic.lon',\n    'GLAT': 'pos.galactic.lat',\n    'ELON': 'pos.ecliptic.lon',\n    'ELAT': 'pos.ecliptic.lat',\n    'TLON': 'pos.bodyrc.lon',\n    'TLAT': 'pos.bodyrc.lat',\n    'HPLT': 'custom:pos.helioprojective.lat',\n    'HPLN': 'custom:pos.helioprojective.lon',\n    'HPRZ': 'custom:pos.helioprojective.z',\n    'HGLN': 'custom:pos.heliographic.stonyhurst.lon',\n    'HGLT': 'custom:pos.heliographic.stonyhurst.lat',\n    'CRLN': 'custom:pos.heliographic.carrington.lon',\n    'CRLT': 'custom:pos.heliographic.carrington.lat',\n    'SOLX': 'custom:pos.heliocentric.x',\n    'SOLY': 'custom:pos.heliocentric.y',\n    'SOLZ': 'custom:pos.heliocentric.z',\n\n    # Spectral coordinates (WCS paper 3)\n    'FREQ': 'em.freq',  # Frequency\n    'ENER': 'em.energy',  # Energy\n    'WAVN': 'em.wavenumber',  # Wavenumber\n    'WAVE': 'em.wl',  # Vacuum wavelength\n    'VRAD': 'spect.dopplerVeloc.radio',  # Radio velocity\n    'VOPT': 'spect.dopplerVeloc.opt',  # Optical velocity\n    'ZOPT': 'src.redshift',  # Redshift\n    'AWAV': 'em.wl',  # Air wavelength\n    'VELO': 'spect.dopplerVeloc',  # Apparent radial velocity\n    'BETA': 'custom:spect.doplerVeloc.beta',  # Beta factor (v/c)\n    'STOKES': 'phys.polarization.stokes',  # STOKES parameters\n\n    # Time coordinates (https://www.aanda.org/articles/aa/pdf/2015/02/aa24653-14.pdf)\n    'TIME': 'time',\n    'TAI': 'time',\n    'TT': 'time',\n    'TDT': 'time',\n    'ET': 'time',\n    'IAT': 'time',\n    'UT1': 'time',\n    'UTC': 'time',\n    'GMT': 'time',\n    'GPS': 'time',\n    'TCG': 'time',\n    'TCB': 'time',\n    'TDB': 'time',\n    'LOCAL': 'time',\n\n    # Distance coordinates\n    'DIST': 'pos.distance',\n    'DSUN': 'custom:pos.distance.sunToObserver'\n\n    # UT() and TT() are handled separately in world_axis_physical_types\n\n}\n\n# Keep a list of additional custom mappings that have been registered. This\n# is kept as a list in case nested context managers are used\nCTYPE_TO_UCD1_CUSTOM = []\n\n\nclass custom_ctype_to_ucd_mapping:\n    \"\"\"\n    A context manager that makes it possible to temporarily add new CTYPE to\n    UCD1+ mapping used by :attr:`FITSWCSAPIMixin.world_axis_physical_types`.\n\n    Parameters\n    ----------\n    mapping : dict\n        A dictionary mapping a CTYPE value to a UCD1+ value\n\n    Examples\n    --------\n\n    Consider a WCS with the following CTYPE::\n\n        >>> from astropy.wcs import WCS\n        >>> wcs = WCS(naxis=1)\n        >>> wcs.wcs.ctype = ['SPAM']\n\n    By default, :attr:`FITSWCSAPIMixin.world_axis_physical_types` returns `None`,\n    but this can be overridden::\n\n        >>> wcs.world_axis_physical_types\n        [None]\n        >>> with custom_ctype_to_ucd_mapping({'SPAM': 'food.spam'}):\n        ...     wcs.world_axis_physical_types\n        ['food.spam']\n    \"\"\"\n\n    def __init__(self, mapping):\n        CTYPE_TO_UCD1_CUSTOM.insert(0, mapping)\n        self.mapping = mapping\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, type, value, tb):\n        CTYPE_TO_UCD1_CUSTOM.remove(self.mapping)\n\n\nclass SlicedFITSWCS(SlicedLowLevelWCS, HighLevelWCSMixin):\n    pass\n\n\nclass FITSWCSAPIMixin(BaseLowLevelWCS, HighLevelWCSMixin):\n    \"\"\"\n    A mix-in class that is intended to be inherited by the\n    :class:`~astropy.wcs.WCS` class and provides the low- and high-level WCS API\n    \"\"\"\n\n    @property\n    def pixel_n_dim(self):\n        return self.naxis\n\n    @property\n    def world_n_dim(self):\n        return len(self.wcs.ctype)\n\n    @property\n    def array_shape(self):\n        if self.pixel_shape is None:\n            return None\n        else:\n            return self.pixel_shape[::-1]\n\n    @array_shape.setter\n    def array_shape(self, value):\n        if value is None:\n            self.pixel_shape = None\n        else:\n            self.pixel_shape = value[::-1]\n\n    @property\n    def pixel_shape(self):\n        if self._naxis == [0, 0]:\n            return None\n        else:\n            return tuple(self._naxis)\n\n    @pixel_shape.setter\n    def pixel_shape(self, value):\n        if value is None:\n            self._naxis = [0, 0]\n        else:\n            if len(value) != self.naxis:\n                raise ValueError(\"The number of data axes, \"\n                                 \"{}, does not equal the \"\n                                 \"shape {}.\".format(self.naxis, len(value)))\n            self._naxis = list(value)\n\n    @property\n    def pixel_bounds(self):\n        return self._pixel_bounds\n\n    @pixel_bounds.setter\n    def pixel_bounds(self, value):\n        if value is None:\n            self._pixel_bounds = value\n        else:\n            if len(value) != self.naxis:\n                raise ValueError(\"The number of data axes, \"\n                                 \"{}, does not equal the number of \"\n                                 \"pixel bounds {}.\".format(self.naxis, len(value)))\n            self._pixel_bounds = list(value)\n\n    @property\n    def world_axis_physical_types(self):\n        types = []\n        # TODO: need to support e.g. TT(TAI)\n        for ctype in self.wcs.ctype:\n            if ctype.upper().startswith(('UT(', 'TT(')):\n                types.append('time')\n            else:\n                ctype_name = ctype.split('-')[0]\n                for custom_mapping in CTYPE_TO_UCD1_CUSTOM:\n                    if ctype_name in custom_mapping:\n                        types.append(custom_mapping[ctype_name])\n                        break\n                else:\n                    types.append(CTYPE_TO_UCD1.get(ctype_name.upper(), None))\n        return types\n\n    @property\n    def world_axis_units(self):\n        units = []\n        for unit in self.wcs.cunit:\n            if unit is None:\n                unit = ''\n            elif isinstance(unit, u.Unit):\n                unit = unit.to_string(format='vounit')\n            else:\n                try:\n                    unit = u.Unit(unit).to_string(format='vounit')\n                except u.UnitsError:\n                    unit = ''\n            units.append(unit)\n        return units\n\n    @property\n    def world_axis_names(self):\n        return list(self.wcs.cname)\n\n    @property\n    def axis_correlation_matrix(self):\n\n        # If there are any distortions present, we assume that there may be\n        # correlations between all axes. Maybe if some distortions only apply\n        # to the image plane we can improve this?\n        if self.has_distortion:\n            return np.ones((self.world_n_dim, self.pixel_n_dim), dtype=bool)\n\n        # Assuming linear world coordinates along each axis, the correlation\n        # matrix would be given by whether or not the PC matrix is zero\n        matrix = self.wcs.get_pc() != 0\n\n        # We now need to check specifically for celestial coordinates since\n        # these can assume correlations because of spherical distortions. For\n        # each celestial coordinate we copy over the pixel dependencies from\n        # the other celestial coordinates.\n        celestial = (self.wcs.axis_types // 1000) % 10 == 2\n        celestial_indices = np.nonzero(celestial)[0]\n        for world1 in celestial_indices:\n            for world2 in celestial_indices:\n                if world1 != world2:\n                    matrix[world1] |= matrix[world2]\n                    matrix[world2] |= matrix[world1]\n\n        return matrix\n\n    def pixel_to_world_values(self, *pixel_arrays):\n        world = self.all_pix2world(*pixel_arrays, 0)\n        return world[0] if self.world_n_dim == 1 else tuple(world)\n\n    def world_to_pixel_values(self, *world_arrays):\n        # avoid circular import\n        from astropy.wcs.wcs import NoConvergence\n        try:\n            pixel = self.all_world2pix(*world_arrays, 0)\n        except NoConvergence as e:\n            warnings.warn(str(e))\n            # use best_solution contained in the exception and format the same\n            # way as all_world2pix does (using _array_converter)\n            pixel = self._array_converter(lambda *args: e.best_solution,\n                                         'input', *world_arrays, 0)\n\n        return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n\n    @property\n    def world_axis_object_components(self):\n        return self._get_components_and_classes()[0]\n\n    @property\n    def world_axis_object_classes(self):\n        return self._get_components_and_classes()[1]\n\n    @property\n    def serialized_classes(self):\n        return False\n\n    def _get_components_and_classes(self):\n\n        # The aim of this function is to return whatever is needed for\n        # world_axis_object_components and world_axis_object_classes. It's easier\n        # to figure it out in one go and then return the values and let the\n        # properties return part of it.\n\n        # Since this method might get called quite a few times, we need to cache\n        # it. We start off by defining a hash based on the attributes of the\n        # WCS that matter here (we can't just use the WCS object as a hash since\n        # it is mutable)\n        wcs_hash = (self.naxis,\n                    list(self.wcs.ctype),\n                    list(self.wcs.cunit),\n                    self.wcs.radesys,\n                    self.wcs.specsys,\n                    self.wcs.equinox,\n                    self.wcs.dateobs,\n                    self.wcs.lng,\n                    self.wcs.lat)\n\n        # If the cache is present, we need to check that the 'hash' matches.\n        if getattr(self, '_components_and_classes_cache', None) is not None:\n            cache = self._components_and_classes_cache\n            if cache[0] == wcs_hash:\n                return cache[1]\n            else:\n                self._components_and_classes_cache = None\n\n        # Avoid circular imports by importing here\n        from astropy.wcs.utils import wcs_to_celestial_frame\n        from astropy.coordinates import SkyCoord, EarthLocation\n        from astropy.time.formats import FITS_DEPRECATED_SCALES\n        from astropy.time import Time, TimeDelta\n\n        components = [None] * self.naxis\n        classes = {}\n\n        # Let's start off by checking whether the WCS has a pair of celestial\n        # components\n\n        if self.has_celestial:\n\n            try:\n                celestial_frame = wcs_to_celestial_frame(self)\n            except ValueError:\n                # Some WCSes, e.g. solar, can be recognized by WCSLIB as being\n                # celestial but we don't necessarily have frames for them.\n                celestial_frame = None\n            else:\n\n                kwargs = {}\n                kwargs['frame'] = celestial_frame\n                kwargs['unit'] = u.deg\n\n                classes['celestial'] = (SkyCoord, (), kwargs)\n\n                components[self.wcs.lng] = ('celestial', 0, 'spherical.lon.degree')\n                components[self.wcs.lat] = ('celestial', 1, 'spherical.lat.degree')\n\n        # Next, we check for spectral components\n\n        if self.has_spectral:\n\n            # Find index of spectral coordinate\n            ispec = self.wcs.spec\n            ctype = self.wcs.ctype[ispec][:4]\n            ctype = ctype.upper()\n\n            kwargs = {}\n\n            # Determine observer location and velocity\n\n            # TODO: determine how WCS standard would deal with observer on a\n            # spacecraft far from earth. For now assume the obsgeo parameters,\n            # if present, give the geocentric observer location.\n\n            if np.isnan(self.wcs.obsgeo[0]):\n                observer = None\n            else:\n\n                earth_location = EarthLocation(*self.wcs.obsgeo[:3], unit=u.m)\n                obstime = Time(self.wcs.mjdobs, format='mjd', scale='utc',\n                               location=earth_location)\n                observer_location = SkyCoord(earth_location.get_itrs(obstime=obstime))\n\n                if self.wcs.specsys in VELOCITY_FRAMES:\n                    frame = VELOCITY_FRAMES[self.wcs.specsys]\n                    observer = observer_location.transform_to(frame)\n                    if isinstance(frame, str):\n                        observer = attach_zero_velocities(observer)\n                    else:\n                        observer = update_differentials_to_match(observer_location,\n                                                                 VELOCITY_FRAMES[self.wcs.specsys],\n                                                                 preserve_observer_frame=True)\n                elif self.wcs.specsys == 'TOPOCENT':\n                    observer = attach_zero_velocities(observer_location)\n                else:\n                    raise NotImplementedError(f'SPECSYS={self.wcs.specsys} not yet supported')\n\n            # Determine target\n\n            # This is tricker. In principle the target for each pixel is the\n            # celestial coordinates of the pixel, but we then need to be very\n            # careful about SSYSOBS which is tricky. For now, we set the\n            # target using the reference celestial coordinate in the WCS (if\n            # any).\n\n            if self.has_celestial and celestial_frame is not None:\n\n                # NOTE: celestial_frame was defined higher up\n\n                # NOTE: we set the distance explicitly to avoid warnings in SpectralCoord\n\n                target = SkyCoord(self.wcs.crval[self.wcs.lng] * self.wcs.cunit[self.wcs.lng],\n                                  self.wcs.crval[self.wcs.lat] * self.wcs.cunit[self.wcs.lat],\n                                  frame=celestial_frame,\n                                  distance=1000 * u.kpc)\n\n                target = attach_zero_velocities(target)\n\n            else:\n\n                target = None\n\n            # SpectralCoord does not work properly if either observer or target\n            # are not convertible to ICRS, so if this is the case, we (for now)\n            # drop the observer and target from the SpectralCoord and warn the\n            # user.\n\n            if observer is not None:\n                try:\n                    observer.transform_to(ICRS())\n                except Exception:\n                    warnings.warn('observer cannot be converted to ICRS, so will '\n                                  'not be set on SpectralCoord', AstropyUserWarning)\n                    observer = None\n\n            if target is not None:\n                try:\n                    target.transform_to(ICRS())\n                except Exception:\n                    warnings.warn('target cannot be converted to ICRS, so will '\n                                  'not be set on SpectralCoord', AstropyUserWarning)\n                    target = None\n\n            # NOTE: below we include Quantity in classes['spectral'] instead\n            # of SpectralCoord - this is because we want to also be able to\n            # accept plain quantities.\n\n            if ctype == 'ZOPT':\n\n                def spectralcoord_from_redshift(redshift):\n                    if isinstance(redshift, SpectralCoord):\n                        return redshift\n                    return SpectralCoord((redshift + 1) * self.wcs.restwav,\n                                         unit=u.m, observer=observer, target=target)\n\n                def redshift_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(u.m) / self.wcs.restwav - 1.\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(u.m) / self.wcs.restwav - 1.\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_redshift)\n                components[self.wcs.spec] = ('spectral', 0, redshift_from_spectralcoord)\n\n            elif ctype == 'BETA':\n\n                def spectralcoord_from_beta(beta):\n                    if isinstance(beta, SpectralCoord):\n                        return beta\n                    return SpectralCoord(beta * C_SI,\n                                         unit=u.m / u.s,\n                                         doppler_convention='relativistic',\n                                         doppler_rest=self.wcs.restwav * u.m,\n                                         observer=observer, target=target)\n\n                def beta_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    doppler_equiv = u.doppler_relativistic(self.wcs.restwav * u.m)\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(u.m / u.s, doppler_equiv) / C_SI\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(u.m / u.s, doppler_equiv) / C_SI\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_beta)\n                components[self.wcs.spec] = ('spectral', 0, beta_from_spectralcoord)\n\n            else:\n\n                kwargs['unit'] = self.wcs.cunit[ispec]\n\n                if self.wcs.restfrq > 0:\n                    if ctype == 'VELO':\n                        kwargs['doppler_convention'] = 'relativistic'\n                        kwargs['doppler_rest'] = self.wcs.restfrq * u.Hz\n                    elif ctype == 'VRAD':\n                        kwargs['doppler_convention'] = 'radio'\n                        kwargs['doppler_rest'] = self.wcs.restfrq * u.Hz\n                    elif ctype == 'VOPT':\n                        kwargs['doppler_convention'] = 'optical'\n                        kwargs['doppler_rest'] = self.wcs.restwav * u.m\n\n                def spectralcoord_from_value(value):\n                    return SpectralCoord(value, observer=observer, target=target, **kwargs)\n\n                def value_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(**kwargs)\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(**kwargs)\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_value)\n                components[self.wcs.spec] = ('spectral', 0, value_from_spectralcoord)\n\n        # We can then make sure we correctly return Time objects where appropriate\n        # (https://www.aanda.org/articles/aa/pdf/2015/02/aa24653-14.pdf)\n\n        if 'time' in self.world_axis_physical_types:\n\n            multiple_time = self.world_axis_physical_types.count('time') > 1\n\n            for i in range(self.naxis):\n\n                if self.world_axis_physical_types[i] == 'time':\n\n                    if multiple_time:\n                        name = f'time.{i}'\n                    else:\n                        name = 'time'\n\n                    # Initialize delta\n                    reference_time_delta = None\n\n                    # Extract time scale\n                    scale = self.wcs.ctype[i].lower()\n\n                    if scale == 'time':\n                        if self.wcs.timesys:\n                            scale = self.wcs.timesys.lower()\n                        else:\n                            scale = 'utc'\n\n                    # Drop sub-scales\n                    if '(' in scale:\n                        pos = scale.index('(')\n                        scale, subscale = scale[:pos], scale[pos+1:-1]\n                        warnings.warn(f'Dropping unsupported sub-scale '\n                                      f'{subscale.upper()} from scale {scale.upper()}',\n                                      UserWarning)\n\n                    # TODO: consider having GPS as a scale in Time\n                    # For now GPS is not a scale, we approximate this by TAI - 19s\n                    if scale == 'gps':\n                        reference_time_delta = TimeDelta(19, format='sec')\n                        scale = 'tai'\n\n                    elif scale.upper() in FITS_DEPRECATED_SCALES:\n                        scale = FITS_DEPRECATED_SCALES[scale.upper()]\n\n                    elif scale not in Time.SCALES:\n                        raise ValueError(f'Unrecognized time CTYPE={self.wcs.ctype[i]}')\n\n                    # Determine location\n                    trefpos = self.wcs.trefpos.lower()\n\n                    if trefpos.startswith('topocent'):\n                        # Note that some headers use TOPOCENT instead of TOPOCENTER\n                        if np.any(np.isnan(self.wcs.obsgeo[:3])):\n                            warnings.warn('Missing or incomplete observer location '\n                                          'information, setting location in Time to None',\n                                          UserWarning)\n                            location = None\n                        else:\n                            location = EarthLocation(*self.wcs.obsgeo[:3], unit=u.m)\n                    elif trefpos == 'geocenter':\n                        location = EarthLocation(0, 0, 0, unit=u.m)\n                    elif trefpos == '':\n                        location = None\n                    else:\n                        # TODO: implement support for more locations when Time supports it\n                        warnings.warn(f\"Observation location '{trefpos}' is not \"\n                                       \"supported, setting location in Time to None\", UserWarning)\n                        location = None\n\n                    reference_time = Time(np.nan_to_num(self.wcs.mjdref[0]),\n                                          np.nan_to_num(self.wcs.mjdref[1]),\n                                          format='mjd', scale=scale,\n                                          location=location)\n\n                    if reference_time_delta is not None:\n                        reference_time = reference_time + reference_time_delta\n\n                    def time_from_reference_and_offset(offset):\n                        if isinstance(offset, Time):\n                            return offset\n                        return reference_time + TimeDelta(offset, format='sec')\n\n                    def offset_from_time_and_reference(time):\n                        return (time - reference_time).sec\n\n                    classes[name] = (Time, (), {}, time_from_reference_and_offset)\n                    components[i] = (name, 0, offset_from_time_and_reference)\n\n        # Fallback: for any remaining components that haven't been identified, just\n        # return Quantity as the class to use\n\n        for i in range(self.naxis):\n            if components[i] is None:\n                name = self.wcs.ctype[i].split('-')[0].lower()\n                if name == '':\n                    name = 'world'\n                while name in classes:\n                    name += \"_\"\n                classes[name] = (u.Quantity, (), {'unit': self.wcs.cunit[i]})\n                components[i] = (name, 0, 'value')\n\n        # Keep a cached version of result\n        self._components_and_classes_cache = wcs_hash, (components, classes)\n\n        return components, classes"
            ]
        ],
        "style": "rule"
    },
    "extra_info": {
        "file_contents": [
            "=======\nAstropy\n=======\n\n|Actions Status| |CircleCI Status| |Azure Status| |Coverage Status| |PyPI Status| |Documentation Status| |Zenodo|\n\nThe Astropy Project (http://astropy.org/) is a community effort to develop a\nsingle core package for Astronomy in Python and foster interoperability between\nPython astronomy packages. This repository contains the core package which is\nintended to contain much of the core functionality and some common tools needed\nfor performing astronomy and astrophysics with Python.\n\nReleases are `registered on PyPI <https://pypi.org/project/astropy>`_,\nand development is occurring at the\n`project's GitHub page <http://github.com/astropy/astropy>`_.\n\nFor installation instructions, see the `online documentation <https://docs.astropy.org/>`_\nor  `docs/install.rst <docs/install.rst>`_ in this source distribution.\n\nContributing Code, Documentation, or Feedback\n---------------------------------------------\n\nThe Astropy Project is made both by and for its users, so we welcome and\nencourage contributions of many kinds. Our goal is to keep this a positive,\ninclusive, successful, and growing community by abiding with the\n`Astropy Community Code of Conduct <http://www.astropy.org/about.html#codeofconduct>`_.\n\nMore detailed information on contributing to the project or submitting feedback\ncan be found on the `contributions <http://www.astropy.org/contribute.html>`_\npage. A `summary of contribution guidelines <CONTRIBUTING.md>`_ can also be\nused as a quick reference when you are ready to start writing or validating\ncode for submission.\n\nSupporting the Project\n----------------------\n\n|NumFOCUS| |Donate|\n\nThe Astropy Project is sponsored by NumFOCUS, a 501(c)(3) nonprofit in the\nUnited States. You can donate to the project by using the link above, and this\ndonation will support our mission to promote sustainable, high-level code base\nfor the astronomy community, open code development, educational materials, and\nreproducible scientific research.\n\nLicense\n-------\n\nAstropy is licensed under a 3-clause BSD style license - see the\n`LICENSE.rst <LICENSE.rst>`_ file.\n\n.. |Actions Status| image:: https://github.com/astropy/astropy/workflows/CI/badge.svg\n    :target: https://github.com/astropy/astropy/actions\n    :alt: Astropy's GitHub Actions CI Status\n\n.. |CircleCI Status| image::  https://img.shields.io/circleci/build/github/astropy/astropy/main?logo=circleci&label=CircleCI\n    :target: https://circleci.com/gh/astropy/astropy\n    :alt: Astropy's CircleCI Status\n\n.. |Azure Status| image:: https://dev.azure.com/astropy-project/astropy/_apis/build/status/astropy.astropy?repoName=astropy%2Fastropy&branchName=main\n    :target: https://dev.azure.com/astropy-project/astropy\n    :alt: Astropy's Azure Pipelines Status\n\n.. |Coverage Status| image:: https://codecov.io/gh/astropy/astropy/branch/main/graph/badge.svg\n    :target: https://codecov.io/gh/astropy/astropy\n    :alt: Astropy's Coverage Status\n\n.. |PyPI Status| image:: https://img.shields.io/pypi/v/astropy.svg\n    :target: https://pypi.org/project/astropy\n    :alt: Astropy's PyPI Status\n\n.. |Zenodo| image:: https://zenodo.org/badge/DOI/10.5281/zenodo.4670728.svg\n   :target: https://doi.org/10.5281/zenodo.4670728\n   :alt: Zenodo DOI\n\n.. |Documentation Status| image:: https://img.shields.io/readthedocs/astropy/latest.svg?logo=read%20the%20docs&logoColor=white&label=Docs&version=stable\n    :target: https://docs.astropy.org/en/stable/?badge=stable\n    :alt: Documentation Status\n\n.. |NumFOCUS| image:: https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A\n    :target: http://numfocus.org\n    :alt: Powered by NumFOCUS\n\n.. |Donate| image:: https://img.shields.io/badge/Donate-to%20Astropy-brightgreen.svg\n    :target: https://numfocus.salsalabs.org/donate-to-astropy/index.html\n\n\nIf you locally cloned this repo before 7 Apr 2021\n-------------------------------------------------\n\nThe primary branch for this repo has been transitioned from ``master`` to\n``main``.  If you have a local clone of this repository and want to keep your\nlocal branch in sync with this repo, you'll need to do the following in your\nlocal clone from your terminal::\n\n   git fetch --all --prune\n   # you can stop here if you don't use your local \"master\"/\"main\" branch\n   git branch -m master main\n   git branch -u origin/main main\n\nIf you are using a GUI to manage your repos you'll have to find the equivalent\ncommands as it's different for different programs. Alternatively, you can just\ndelete your local clone and re-clone!",
            "# This file includes the definition of a mix-in class that provides the low-\n# and high-level WCS API to the astropy.wcs.WCS object. We keep this code\n# isolated in this mix-in class to avoid making the main wcs.py file too\n# long.\n\nimport warnings\n\nimport numpy as np\n\nfrom astropy import units as u\nfrom astropy.coordinates import SpectralCoord, Galactic, ICRS\nfrom astropy.coordinates.spectral_coordinate import update_differentials_to_match, attach_zero_velocities\nfrom astropy.utils.exceptions import AstropyUserWarning\nfrom astropy.constants import c\n\nfrom .low_level_api import BaseLowLevelWCS\nfrom .high_level_api import HighLevelWCSMixin\nfrom .wrappers import SlicedLowLevelWCS\n\n__all__ = ['custom_ctype_to_ucd_mapping', 'SlicedFITSWCS', 'FITSWCSAPIMixin']\n\nC_SI = c.si.value\n\nVELOCITY_FRAMES = {\n    'GEOCENT': 'gcrs',\n    'BARYCENT': 'icrs',\n    'HELIOCENT': 'hcrs',\n    'LSRK': 'lsrk',\n    'LSRD': 'lsrd'\n}\n\n# The spectra velocity frames below are needed for FITS spectral WCS\n#  (see Greisen 06 table 12) but aren't yet defined as real\n# astropy.coordinates frames, so we instead define them here as instances\n# of existing coordinate frames with offset velocities. In future we should\n# make these real frames so that users can more easily recognize these\n# velocity frames when used in SpectralCoord.\n\n# This frame is defined as a velocity of 220 km/s in the\n# direction of l=90, b=0. The rotation velocity is defined\n# in:\n#\n#   Kerr and Lynden-Bell 1986, Review of galactic constants.\n#\n# NOTE: this may differ from the assumptions of galcen_v_sun\n# in the Galactocentric frame - the value used here is\n# the one adopted by the WCS standard for spectral\n# transformations.\n\nVELOCITY_FRAMES['GALACTOC'] = Galactic(u=0 * u.km, v=0 * u.km, w=0 * u.km,\n                                       U=0 * u.km / u.s, V=-220 * u.km / u.s, W=0 * u.km / u.s,\n                                       representation_type='cartesian',\n                                       differential_type='cartesian')\n\n# This frame is defined as a velocity of 300 km/s in the\n# direction of l=90, b=0. This is defined in:\n#\n#   Transactions of the IAU Vol. XVI B Proceedings of the\n#   16th General Assembly, Reports of Meetings of Commissions:\n#   Comptes Rendus Des Séances Des Commissions, Commission 28,\n#   p201.\n#\n# Note that these values differ from those used by CASA\n# (308 km/s towards l=105, b=-7) but we use the above values\n# since these are the ones defined in Greisen et al (2006).\n\nVELOCITY_FRAMES['LOCALGRP'] = Galactic(u=0 * u.km, v=0 * u.km, w=0 * u.km,\n                                       U=0 * u.km / u.s, V=-300 * u.km / u.s, W=0 * u.km / u.s,\n                                       representation_type='cartesian',\n                                       differential_type='cartesian')\n\n# This frame is defined as a velocity of 368 km/s in the\n# direction of l=263.85, b=48.25. This is defined in:\n#\n#   Bennett et al. (2003), First-Year Wilkinson Microwave\n#   Anisotropy Probe (WMAP) Observations: Preliminary Maps\n#   and Basic Results\n#\n# Note that in that paper, the dipole is expressed as a\n# temperature (T=3.346 +/- 0.017mK)\n\nVELOCITY_FRAMES['CMBDIPOL'] = Galactic(l=263.85 * u.deg, b=48.25 * u.deg, distance=0 * u.km,\n                                       radial_velocity=-(3.346e-3 / 2.725 * c).to(u.km/u.s))\n\n\n# Mapping from CTYPE axis name to UCD1\n\nCTYPE_TO_UCD1 = {\n\n    # Celestial coordinates\n    'RA': 'pos.eq.ra',\n    'DEC': 'pos.eq.dec',\n    'GLON': 'pos.galactic.lon',\n    'GLAT': 'pos.galactic.lat',\n    'ELON': 'pos.ecliptic.lon',\n    'ELAT': 'pos.ecliptic.lat',\n    'TLON': 'pos.bodyrc.lon',\n    'TLAT': 'pos.bodyrc.lat',\n    'HPLT': 'custom:pos.helioprojective.lat',\n    'HPLN': 'custom:pos.helioprojective.lon',\n    'HPRZ': 'custom:pos.helioprojective.z',\n    'HGLN': 'custom:pos.heliographic.stonyhurst.lon',\n    'HGLT': 'custom:pos.heliographic.stonyhurst.lat',\n    'CRLN': 'custom:pos.heliographic.carrington.lon',\n    'CRLT': 'custom:pos.heliographic.carrington.lat',\n    'SOLX': 'custom:pos.heliocentric.x',\n    'SOLY': 'custom:pos.heliocentric.y',\n    'SOLZ': 'custom:pos.heliocentric.z',\n\n    # Spectral coordinates (WCS paper 3)\n    'FREQ': 'em.freq',  # Frequency\n    'ENER': 'em.energy',  # Energy\n    'WAVN': 'em.wavenumber',  # Wavenumber\n    'WAVE': 'em.wl',  # Vacuum wavelength\n    'VRAD': 'spect.dopplerVeloc.radio',  # Radio velocity\n    'VOPT': 'spect.dopplerVeloc.opt',  # Optical velocity\n    'ZOPT': 'src.redshift',  # Redshift\n    'AWAV': 'em.wl',  # Air wavelength\n    'VELO': 'spect.dopplerVeloc',  # Apparent radial velocity\n    'BETA': 'custom:spect.doplerVeloc.beta',  # Beta factor (v/c)\n    'STOKES': 'phys.polarization.stokes',  # STOKES parameters\n\n    # Time coordinates (https://www.aanda.org/articles/aa/pdf/2015/02/aa24653-14.pdf)\n    'TIME': 'time',\n    'TAI': 'time',\n    'TT': 'time',\n    'TDT': 'time',\n    'ET': 'time',\n    'IAT': 'time',\n    'UT1': 'time',\n    'UTC': 'time',\n    'GMT': 'time',\n    'GPS': 'time',\n    'TCG': 'time',\n    'TCB': 'time',\n    'TDB': 'time',\n    'LOCAL': 'time',\n\n    # Distance coordinates\n    'DIST': 'pos.distance',\n    'DSUN': 'custom:pos.distance.sunToObserver'\n\n    # UT() and TT() are handled separately in world_axis_physical_types\n\n}\n\n# Keep a list of additional custom mappings that have been registered. This\n# is kept as a list in case nested context managers are used\nCTYPE_TO_UCD1_CUSTOM = []\n\n\nclass custom_ctype_to_ucd_mapping:\n    \"\"\"\n    A context manager that makes it possible to temporarily add new CTYPE to\n    UCD1+ mapping used by :attr:`FITSWCSAPIMixin.world_axis_physical_types`.\n\n    Parameters\n    ----------\n    mapping : dict\n        A dictionary mapping a CTYPE value to a UCD1+ value\n\n    Examples\n    --------\n\n    Consider a WCS with the following CTYPE::\n\n        >>> from astropy.wcs import WCS\n        >>> wcs = WCS(naxis=1)\n        >>> wcs.wcs.ctype = ['SPAM']\n\n    By default, :attr:`FITSWCSAPIMixin.world_axis_physical_types` returns `None`,\n    but this can be overridden::\n\n        >>> wcs.world_axis_physical_types\n        [None]\n        >>> with custom_ctype_to_ucd_mapping({'SPAM': 'food.spam'}):\n        ...     wcs.world_axis_physical_types\n        ['food.spam']\n    \"\"\"\n\n    def __init__(self, mapping):\n        CTYPE_TO_UCD1_CUSTOM.insert(0, mapping)\n        self.mapping = mapping\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, type, value, tb):\n        CTYPE_TO_UCD1_CUSTOM.remove(self.mapping)\n\n\nclass SlicedFITSWCS(SlicedLowLevelWCS, HighLevelWCSMixin):\n    pass\n\n\nclass FITSWCSAPIMixin(BaseLowLevelWCS, HighLevelWCSMixin):\n    \"\"\"\n    A mix-in class that is intended to be inherited by the\n    :class:`~astropy.wcs.WCS` class and provides the low- and high-level WCS API\n    \"\"\"\n\n    @property\n    def pixel_n_dim(self):\n        return self.naxis\n\n    @property\n    def world_n_dim(self):\n        return len(self.wcs.ctype)\n\n    @property\n    def array_shape(self):\n        if self.pixel_shape is None:\n            return None\n        else:\n            return self.pixel_shape[::-1]\n\n    @array_shape.setter\n    def array_shape(self, value):\n        if value is None:\n            self.pixel_shape = None\n        else:\n            self.pixel_shape = value[::-1]\n\n    @property\n    def pixel_shape(self):\n        if self._naxis == [0, 0]:\n            return None\n        else:\n            return tuple(self._naxis)\n\n    @pixel_shape.setter\n    def pixel_shape(self, value):\n        if value is None:\n            self._naxis = [0, 0]\n        else:\n            if len(value) != self.naxis:\n                raise ValueError(\"The number of data axes, \"\n                                 \"{}, does not equal the \"\n                                 \"shape {}.\".format(self.naxis, len(value)))\n            self._naxis = list(value)\n\n    @property\n    def pixel_bounds(self):\n        return self._pixel_bounds\n\n    @pixel_bounds.setter\n    def pixel_bounds(self, value):\n        if value is None:\n            self._pixel_bounds = value\n        else:\n            if len(value) != self.naxis:\n                raise ValueError(\"The number of data axes, \"\n                                 \"{}, does not equal the number of \"\n                                 \"pixel bounds {}.\".format(self.naxis, len(value)))\n            self._pixel_bounds = list(value)\n\n    @property\n    def world_axis_physical_types(self):\n        types = []\n        # TODO: need to support e.g. TT(TAI)\n        for ctype in self.wcs.ctype:\n            if ctype.upper().startswith(('UT(', 'TT(')):\n                types.append('time')\n            else:\n                ctype_name = ctype.split('-')[0]\n                for custom_mapping in CTYPE_TO_UCD1_CUSTOM:\n                    if ctype_name in custom_mapping:\n                        types.append(custom_mapping[ctype_name])\n                        break\n                else:\n                    types.append(CTYPE_TO_UCD1.get(ctype_name.upper(), None))\n        return types\n\n    @property\n    def world_axis_units(self):\n        units = []\n        for unit in self.wcs.cunit:\n            if unit is None:\n                unit = ''\n            elif isinstance(unit, u.Unit):\n                unit = unit.to_string(format='vounit')\n            else:\n                try:\n                    unit = u.Unit(unit).to_string(format='vounit')\n                except u.UnitsError:\n                    unit = ''\n            units.append(unit)\n        return units\n\n    @property\n    def world_axis_names(self):\n        return list(self.wcs.cname)\n\n    @property\n    def axis_correlation_matrix(self):\n\n        # If there are any distortions present, we assume that there may be\n        # correlations between all axes. Maybe if some distortions only apply\n        # to the image plane we can improve this?\n        if self.has_distortion:\n            return np.ones((self.world_n_dim, self.pixel_n_dim), dtype=bool)\n\n        # Assuming linear world coordinates along each axis, the correlation\n        # matrix would be given by whether or not the PC matrix is zero\n        matrix = self.wcs.get_pc() != 0\n\n        # We now need to check specifically for celestial coordinates since\n        # these can assume correlations because of spherical distortions. For\n        # each celestial coordinate we copy over the pixel dependencies from\n        # the other celestial coordinates.\n        celestial = (self.wcs.axis_types // 1000) % 10 == 2\n        celestial_indices = np.nonzero(celestial)[0]\n        for world1 in celestial_indices:\n            for world2 in celestial_indices:\n                if world1 != world2:\n                    matrix[world1] |= matrix[world2]\n                    matrix[world2] |= matrix[world1]\n\n        return matrix\n\n    def pixel_to_world_values(self, *pixel_arrays):\n        world = self.all_pix2world(*pixel_arrays, 0)\n        return world[0] if self.world_n_dim == 1 else tuple(world)\n\n    def world_to_pixel_values(self, *world_arrays):\n        pixel = self.all_world2pix(*world_arrays, 0)\n        return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n\n    @property\n    def world_axis_object_components(self):\n        return self._get_components_and_classes()[0]\n\n    @property\n    def world_axis_object_classes(self):\n        return self._get_components_and_classes()[1]\n\n    @property\n    def serialized_classes(self):\n        return False\n\n    def _get_components_and_classes(self):\n\n        # The aim of this function is to return whatever is needed for\n        # world_axis_object_components and world_axis_object_classes. It's easier\n        # to figure it out in one go and then return the values and let the\n        # properties return part of it.\n\n        # Since this method might get called quite a few times, we need to cache\n        # it. We start off by defining a hash based on the attributes of the\n        # WCS that matter here (we can't just use the WCS object as a hash since\n        # it is mutable)\n        wcs_hash = (self.naxis,\n                    list(self.wcs.ctype),\n                    list(self.wcs.cunit),\n                    self.wcs.radesys,\n                    self.wcs.specsys,\n                    self.wcs.equinox,\n                    self.wcs.dateobs,\n                    self.wcs.lng,\n                    self.wcs.lat)\n\n        # If the cache is present, we need to check that the 'hash' matches.\n        if getattr(self, '_components_and_classes_cache', None) is not None:\n            cache = self._components_and_classes_cache\n            if cache[0] == wcs_hash:\n                return cache[1]\n            else:\n                self._components_and_classes_cache = None\n\n        # Avoid circular imports by importing here\n        from astropy.wcs.utils import wcs_to_celestial_frame\n        from astropy.coordinates import SkyCoord, EarthLocation\n        from astropy.time.formats import FITS_DEPRECATED_SCALES\n        from astropy.time import Time, TimeDelta\n\n        components = [None] * self.naxis\n        classes = {}\n\n        # Let's start off by checking whether the WCS has a pair of celestial\n        # components\n\n        if self.has_celestial:\n\n            try:\n                celestial_frame = wcs_to_celestial_frame(self)\n            except ValueError:\n                # Some WCSes, e.g. solar, can be recognized by WCSLIB as being\n                # celestial but we don't necessarily have frames for them.\n                celestial_frame = None\n            else:\n\n                kwargs = {}\n                kwargs['frame'] = celestial_frame\n                kwargs['unit'] = u.deg\n\n                classes['celestial'] = (SkyCoord, (), kwargs)\n\n                components[self.wcs.lng] = ('celestial', 0, 'spherical.lon.degree')\n                components[self.wcs.lat] = ('celestial', 1, 'spherical.lat.degree')\n\n        # Next, we check for spectral components\n\n        if self.has_spectral:\n\n            # Find index of spectral coordinate\n            ispec = self.wcs.spec\n            ctype = self.wcs.ctype[ispec][:4]\n            ctype = ctype.upper()\n\n            kwargs = {}\n\n            # Determine observer location and velocity\n\n            # TODO: determine how WCS standard would deal with observer on a\n            # spacecraft far from earth. For now assume the obsgeo parameters,\n            # if present, give the geocentric observer location.\n\n            if np.isnan(self.wcs.obsgeo[0]):\n                observer = None\n            else:\n\n                earth_location = EarthLocation(*self.wcs.obsgeo[:3], unit=u.m)\n                obstime = Time(self.wcs.mjdobs, format='mjd', scale='utc',\n                               location=earth_location)\n                observer_location = SkyCoord(earth_location.get_itrs(obstime=obstime))\n\n                if self.wcs.specsys in VELOCITY_FRAMES:\n                    frame = VELOCITY_FRAMES[self.wcs.specsys]\n                    observer = observer_location.transform_to(frame)\n                    if isinstance(frame, str):\n                        observer = attach_zero_velocities(observer)\n                    else:\n                        observer = update_differentials_to_match(observer_location,\n                                                                 VELOCITY_FRAMES[self.wcs.specsys],\n                                                                 preserve_observer_frame=True)\n                elif self.wcs.specsys == 'TOPOCENT':\n                    observer = attach_zero_velocities(observer_location)\n                else:\n                    raise NotImplementedError(f'SPECSYS={self.wcs.specsys} not yet supported')\n\n            # Determine target\n\n            # This is tricker. In principle the target for each pixel is the\n            # celestial coordinates of the pixel, but we then need to be very\n            # careful about SSYSOBS which is tricky. For now, we set the\n            # target using the reference celestial coordinate in the WCS (if\n            # any).\n\n            if self.has_celestial and celestial_frame is not None:\n\n                # NOTE: celestial_frame was defined higher up\n\n                # NOTE: we set the distance explicitly to avoid warnings in SpectralCoord\n\n                target = SkyCoord(self.wcs.crval[self.wcs.lng] * self.wcs.cunit[self.wcs.lng],\n                                  self.wcs.crval[self.wcs.lat] * self.wcs.cunit[self.wcs.lat],\n                                  frame=celestial_frame,\n                                  distance=1000 * u.kpc)\n\n                target = attach_zero_velocities(target)\n\n            else:\n\n                target = None\n\n            # SpectralCoord does not work properly if either observer or target\n            # are not convertible to ICRS, so if this is the case, we (for now)\n            # drop the observer and target from the SpectralCoord and warn the\n            # user.\n\n            if observer is not None:\n                try:\n                    observer.transform_to(ICRS())\n                except Exception:\n                    warnings.warn('observer cannot be converted to ICRS, so will '\n                                  'not be set on SpectralCoord', AstropyUserWarning)\n                    observer = None\n\n            if target is not None:\n                try:\n                    target.transform_to(ICRS())\n                except Exception:\n                    warnings.warn('target cannot be converted to ICRS, so will '\n                                  'not be set on SpectralCoord', AstropyUserWarning)\n                    target = None\n\n            # NOTE: below we include Quantity in classes['spectral'] instead\n            # of SpectralCoord - this is because we want to also be able to\n            # accept plain quantities.\n\n            if ctype == 'ZOPT':\n\n                def spectralcoord_from_redshift(redshift):\n                    if isinstance(redshift, SpectralCoord):\n                        return redshift\n                    return SpectralCoord((redshift + 1) * self.wcs.restwav,\n                                         unit=u.m, observer=observer, target=target)\n\n                def redshift_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(u.m) / self.wcs.restwav - 1.\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(u.m) / self.wcs.restwav - 1.\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_redshift)\n                components[self.wcs.spec] = ('spectral', 0, redshift_from_spectralcoord)\n\n            elif ctype == 'BETA':\n\n                def spectralcoord_from_beta(beta):\n                    if isinstance(beta, SpectralCoord):\n                        return beta\n                    return SpectralCoord(beta * C_SI,\n                                         unit=u.m / u.s,\n                                         doppler_convention='relativistic',\n                                         doppler_rest=self.wcs.restwav * u.m,\n                                         observer=observer, target=target)\n\n                def beta_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    doppler_equiv = u.doppler_relativistic(self.wcs.restwav * u.m)\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(u.m / u.s, doppler_equiv) / C_SI\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(u.m / u.s, doppler_equiv) / C_SI\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_beta)\n                components[self.wcs.spec] = ('spectral', 0, beta_from_spectralcoord)\n\n            else:\n\n                kwargs['unit'] = self.wcs.cunit[ispec]\n\n                if self.wcs.restfrq > 0:\n                    if ctype == 'VELO':\n                        kwargs['doppler_convention'] = 'relativistic'\n                        kwargs['doppler_rest'] = self.wcs.restfrq * u.Hz\n                    elif ctype == 'VRAD':\n                        kwargs['doppler_convention'] = 'radio'\n                        kwargs['doppler_rest'] = self.wcs.restfrq * u.Hz\n                    elif ctype == 'VOPT':\n                        kwargs['doppler_convention'] = 'optical'\n                        kwargs['doppler_rest'] = self.wcs.restwav * u.m\n\n                def spectralcoord_from_value(value):\n                    return SpectralCoord(value, observer=observer, target=target, **kwargs)\n\n                def value_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent\n                    if observer is None:\n                        warnings.warn('No observer defined on WCS, SpectralCoord '\n                                      'will be converted without any velocity '\n                                      'frame change', AstropyUserWarning)\n                        return spectralcoord.to_value(**kwargs)\n                    else:\n                        return spectralcoord.with_observer_stationary_relative_to(observer).to_value(**kwargs)\n\n                classes['spectral'] = (u.Quantity, (), {}, spectralcoord_from_value)\n                components[self.wcs.spec] = ('spectral', 0, value_from_spectralcoord)\n\n        # We can then make sure we correctly return Time objects where appropriate\n        # (https://www.aanda.org/articles/aa/pdf/2015/02/aa24653-14.pdf)\n\n        if 'time' in self.world_axis_physical_types:\n\n            multiple_time = self.world_axis_physical_types.count('time') > 1\n\n            for i in range(self.naxis):\n\n                if self.world_axis_physical_types[i] == 'time':\n\n                    if multiple_time:\n                        name = f'time.{i}'\n                    else:\n                        name = 'time'\n\n                    # Initialize delta\n                    reference_time_delta = None\n\n                    # Extract time scale\n                    scale = self.wcs.ctype[i].lower()\n\n                    if scale == 'time':\n                        if self.wcs.timesys:\n                            scale = self.wcs.timesys.lower()\n                        else:\n                            scale = 'utc'\n\n                    # Drop sub-scales\n                    if '(' in scale:\n                        pos = scale.index('(')\n                        scale, subscale = scale[:pos], scale[pos+1:-1]\n                        warnings.warn(f'Dropping unsupported sub-scale '\n                                      f'{subscale.upper()} from scale {scale.upper()}',\n                                      UserWarning)\n\n                    # TODO: consider having GPS as a scale in Time\n                    # For now GPS is not a scale, we approximate this by TAI - 19s\n                    if scale == 'gps':\n                        reference_time_delta = TimeDelta(19, format='sec')\n                        scale = 'tai'\n\n                    elif scale.upper() in FITS_DEPRECATED_SCALES:\n                        scale = FITS_DEPRECATED_SCALES[scale.upper()]\n\n                    elif scale not in Time.SCALES:\n                        raise ValueError(f'Unrecognized time CTYPE={self.wcs.ctype[i]}')\n\n                    # Determine location\n                    trefpos = self.wcs.trefpos.lower()\n\n                    if trefpos.startswith('topocent'):\n                        # Note that some headers use TOPOCENT instead of TOPOCENTER\n                        if np.any(np.isnan(self.wcs.obsgeo[:3])):\n                            warnings.warn('Missing or incomplete observer location '\n                                          'information, setting location in Time to None',\n                                          UserWarning)\n                            location = None\n                        else:\n                            location = EarthLocation(*self.wcs.obsgeo[:3], unit=u.m)\n                    elif trefpos == 'geocenter':\n                        location = EarthLocation(0, 0, 0, unit=u.m)\n                    elif trefpos == '':\n                        location = None\n                    else:\n                        # TODO: implement support for more locations when Time supports it\n                        warnings.warn(f\"Observation location '{trefpos}' is not \"\n                                       \"supported, setting location in Time to None\", UserWarning)\n                        location = None\n\n                    reference_time = Time(np.nan_to_num(self.wcs.mjdref[0]),\n                                          np.nan_to_num(self.wcs.mjdref[1]),\n                                          format='mjd', scale=scale,\n                                          location=location)\n\n                    if reference_time_delta is not None:\n                        reference_time = reference_time + reference_time_delta\n\n                    def time_from_reference_and_offset(offset):\n                        if isinstance(offset, Time):\n                            return offset\n                        return reference_time + TimeDelta(offset, format='sec')\n\n                    def offset_from_time_and_reference(time):\n                        return (time - reference_time).sec\n\n                    classes[name] = (Time, (), {}, time_from_reference_and_offset)\n                    components[i] = (name, 0, offset_from_time_and_reference)\n\n        # Fallback: for any remaining components that haven't been identified, just\n        # return Quantity as the class to use\n\n        for i in range(self.naxis):\n            if components[i] is None:\n                name = self.wcs.ctype[i].split('-')[0].lower()\n                if name == '':\n                    name = 'world'\n                while name in classes:\n                    name += \"_\"\n                classes[name] = (u.Quantity, (), {'unit': self.wcs.cunit[i]})\n                components[i] = (name, 0, 'value')\n\n        # Keep a cached version of result\n        self._components_and_classes_cache = wcs_hash, (components, classes)\n\n        return components, classes"
        ],
        "file_names": [
            "README.rst",
            "astropy/wcs/wcsapi/fitswcs.py"
        ],
        "index": 0,
        "split": "test"
    },
    "response": "<think>\nThe issue is that the `WCS.all_world2pix` function is failing to converge when trying to plot an image with a WCS that includes non-linear distortions. The error is raised because the solution is diverging after 20 iterations. The workaround provided is to add `quiet=True` to the `all_world2pix` call, which suppresses the error and allows the plot to be generated.\n\nTo fix this issue, we should add a way to pass the `quiet` parameter from the high-level API to the low-level `all_world2pix` function. This can be done by modifying the `world_to_pixel_values` method in `fitswcs.py` to accept and pass the `quiet` parameter.\n\nHere's how we can do it:\n1. Modify the `world_to_pixel_values` method to accept an additional `quiet` parameter with a default value of `False`.\n2. Pass the `quiet` parameter to the `all_world2pix` method call inside `world_to_pixel_values`.\n\nThis change will allow users to suppress the convergence error without modifying the library code directly.\n</think>\n<solution>\n```python\n### astropy/wcs/wcsapi/fitswcs.py\n<<<<<<< SEARCH\n    def world_to_pixel_values(self, *world_arrays):\n        pixel = self.all_world2pix(*world_arrays, 0)\n        return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n=======\n    def world_to_pixel_values(self, *world_arrays, quiet=False):\n        pixel = self.all_world2pix(*world_arrays, 0, quiet=quiet)\n        return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n>>>>>>> REPLACE\n```\n</solution>",
    "reward": 0.555205047318612
}